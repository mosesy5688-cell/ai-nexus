/**
 * Factory Shard Processor V16.8.7 (CES Compliant)
 * 
 * Constitution: Art 3.1-3.4 (Factory Pipeline)
 * V16.8.7: Uses cache-manager for persistent entity checksums (cross-run diff)
 * 
 * Usage: node scripts/factory/shard-processor.js --shard=N --total=20
 */

import fs from 'fs/promises';
import path from 'path';
import zlib from 'zlib';
import { processEntity } from './lib/processor-core.js';
import { loadEntityChecksums, loadDailyAccum, loadFniHistory } from './lib/cache-manager.js';
import { normalizeId, getNodeSource } from '../utils/id-normalizer.js';

// Configuration (Art 3.1)
const CONFIG = {
    TOTAL_SHARDS: 20,
    CHECKPOINT_THRESHOLD_HOURS: 5.5,
    CACHE_DIR: process.env.CACHE_DIR || './cache',
    ARTIFACT_DIR: './artifacts'
};

/**
 * Utility: Parse CLI arguments (Art 3.1)
 */
function parseArgs() {
    const args = process.argv.slice(2);
    const shard = args.find(a => a.startsWith('--shard='))?.split('=')[1];
    const total = args.find(a => a.startsWith('--total='))?.split('=')[1];
    return {
        shardId: parseInt(shard) || 0,
        totalShards: parseInt(total) || 20
    };
}

/**
 * Utility: Save partial results for long-running shards (Art 3.4)
 */
async function saveCheckpoint(shardId, results, lastId) {
    const checkpointPath = `./artifacts/checkpoint-shard-${shardId}.json`;
    await fs.mkdir('./artifacts', { recursive: true });
    await fs.writeFile(checkpointPath, JSON.stringify({
        shardId,
        lastId,
        results,
        timestamp: new Date().toISOString()
    }, null, 2));
}

// Main (V14.5.2: with artifact-based checksum tracking)
async function main() {
    const { shardId, totalShards } = parseArgs();
    console.log(`[SHARD ${shardId}/${totalShards}] Starting...`);

    // V16.2.10: Data Safety Guard - 2/4 stage must NEVER write to R2
    process.env.ENABLE_R2_BACKUP = 'false';

    // V16.11: Load global context
    const [globalStats, entityChecksums, fniHistory] = await Promise.all([
        loadDailyAccum(),
        loadEntityChecksums(),
        loadFniHistory()
    ]);

    // V18.2.1 GA: Sharded Input Support (Art 3.1)
    // Prioritize loading the specific shard generated by Stage 1/4 to avoid monolith OOM/RangeError.
    const shardFilePath = path.join(CONFIG.CACHE_DIR, `merged_shard_${shardId}.json.gz`);
    let shardEntities = [];

    try {
        console.log(`[SHARD ${shardId}] Attempting to load sharded input: ${shardFilePath}`);
        if (await fs.stat(shardFilePath).catch(() => null)) {
            const data = await fs.readFile(shardFilePath);
            const decompressed = zlib.gunzipSync(data);
            shardEntities = JSON.parse(decompressed.toString('utf-8'));
            console.log(`[SHARD ${shardId}] ✓ Loaded ${shardEntities.length} entities from shard.`);
        } else {
            throw new Error('Shard file not found');
        }
    } catch (e) {
        console.warn(`[SHARD ${shardId}] ⚠️ Sharded input missing or corrupt (${e.message}). Falling back to monolith...`);
        const entitiesPath = process.env.ENTITIES_PATH || path.join(CONFIG.CACHE_DIR, 'raw-entities.json');
        const rawEntities = await fs.readFile(entitiesPath).then(data => JSON.parse(data.toString())).catch(() => []);
        shardEntities = rawEntities.filter((_, idx) => idx % totalShards === shardId);
    }

    console.log(`[SHARD ${shardId}] Processing ${shardEntities.length} entities...`);

    // Process
    const results = [];
    const startTime = Date.now();

    for (const entity of shardEntities) {
        // V16.99: Balanced Processing (Full Complete)
        const result = await processEntity(entity, globalStats, entityChecksums, fniHistory, CONFIG);

        // V16.11: Capture FULL data in result for the shard
        // results.push(result); -> already contains enriched and html if processEntity provides it
        results.push({
            ...result,
            // Optimization: if processEntity didn't return them, we normally wouldn't have them
            // In current V16.5 impl, processEntity is expected to return the enriched object
        });

        if (results.length % 500 === 0) {
            console.log(`[SHARD ${shardId}] Progress: ${results.length}/${shardEntities.length}...`);
        }
    }

    // V16.11: Monolithic Compressed Output
    const shardData = {
        shardId,
        totalShards,
        processedCount: results.length,
        successCount: results.filter(r => r.success).length,
        entities: results,
        timestamp: new Date().toISOString(),
        version: '16.11.0-monolithic'
    };

    const json = JSON.stringify(shardData);
    const compressed = zlib.gzipSync(json);

    await fs.mkdir(CONFIG.ARTIFACT_DIR, { recursive: true });
    const outPath = path.join(CONFIG.ARTIFACT_DIR, `shard-${shardId}.json.gz`);
    await fs.writeFile(outPath, compressed);

    console.log(`[SHARD ${shardId}] ✅ Complete. Written to ${outPath} (${(compressed.length / 1024 / 1024).toFixed(2)} MB)`);
}

main().catch(err => {
    console.error('Fatal Shard Error:', err);
    process.exit(1);
});
