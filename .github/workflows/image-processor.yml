# Image Processor Workflow V14.5
# Constitution Reference: Art 3.4 (Image Processing), V14.5 Architecture
# 
# Runs after Factory to download, convert (WebP), and upload entity images to R2

name: Image Processor V14.5

on:
  # Trigger after Factory Upload completes (V14.5 Modular Factory)
  workflow_run:
    workflows: ["Factory 4/4 - Upload"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      batch_size:
        description: 'Number of images to process per run'
        type: number
        default: 500

env:
  R2_BUCKET: ai-nexus-assets
  R2_ENDPOINT: https://${{ secrets.CLOUDFLARE_ACCOUNT_ID }}.r2.cloudflarestorage.com
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}

jobs:
  process-images:
    name: Process Entity Images
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Rust Dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            tools/rust-img-optimizer/target/
          key: rust-img-${{ hashFiles('tools/rust-img-optimizer/Cargo.lock') }}

      - name: Build Rust Optimizer
        working-directory: tools/rust-img-optimizer
        run: cargo build --release

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Install Wrangler
        run: npm install -g wrangler

      # Download global registry from R2 to get image URLs for all 140k entities
      - name: Fetch Global Entity Registry
        run: |
          mkdir -p data/images
          
          # V16.2: Load the persistent registry (The Memory)
          wrangler r2 object get $R2_BUCKET/meta/backup/global-registry.json --pipe > data/registry.json || echo '{"entities":[]}' > data/registry.json
          
          # Extract image URLs needing processing (Prioritize active entities)
          node -e "
          const fs = require('fs');
          const registry = JSON.parse(fs.readFileSync('data/registry.json', 'utf-8'));
          const entities = registry.entities || [];
          
          // V16.2 Strategy: Process all entities with external image URLs
          const imageUrls = entities.filter(e => e.image_url && !e.image_url.includes('free2aitools.com'))
            .sort((a, b) => (b.fni_score || 0) - (a.fni_score || 0)) // Top-FNI first
            .slice(0, ${{ github.event.inputs.batch_size || 500 }})
            .map(e => ({
              id: e.id || e.slug,
              source_url: e.image_url,
              type: e.type || 'model'
            }));
          fs.writeFileSync('data/image-queue.json', JSON.stringify(imageUrls, null, 2));
          console.log('Image queue (Global Registry):', imageUrls.length, 'images');
          "

      - name: Download and Convert Images
        run: |
          echo "ðŸ–¼ï¸ Processing images..."
          
          node -e "
          const fs = require('fs');
          const https = require('https');
          const http = require('http');
          const path = require('path');
          
          const queue = JSON.parse(fs.readFileSync('data/image-queue.json', 'utf-8'));
          const results = { success: 0, failed: 0, skipped: 0 };
          
          async function downloadImage(url, dest) {
            return new Promise((resolve, reject) => {
              const protocol = url.startsWith('https') ? https : http;
              const file = fs.createWriteStream(dest);
              protocol.get(url, { timeout: 15000 }, (response) => {
                if (response.statusCode === 200) {
                  response.pipe(file);
                  file.on('finish', () => { file.close(); resolve(true); });
                } else if (response.statusCode >= 300 && response.statusCode < 400 && response.headers.location) {
                  downloadImage(response.headers.location, dest).then(resolve).catch(reject);
                } else {
                  reject(new Error('Status: ' + response.statusCode));
                }
              }).on('error', reject);
            });
          }
          
          async function processQueue() {
            for (const item of queue) {
              const safeName = (item.id || 'unknown').replace(/[/:]/g, '--');
              const destPath = 'data/images/' + safeName + '.jpg';
              try {
                // Optimization: Skip if already exists in this run's disk
                if (fs.existsSync(destPath)) { results.skipped++; continue; }
                
                await downloadImage(item.source_url, destPath);
                results.success++;
                console.log('âœ…', safeName);
              } catch (err) {
                results.failed++;
                console.log('âŒ', safeName, err.message);
              }
            }
            console.log('Results:', results);
            fs.writeFileSync('data/image-results.json', JSON.stringify(results, null, 2));
          }
          
          processQueue();
          "

      - name: Convert to WebP (Rust)
        working-directory: tools/rust-img-optimizer
        run: |
          echo "ðŸ”„ Converting to WebP..."
          for img in ../../data/images/*.jpg; do
            if [ -f "$img" ]; then
              base=$(basename "$img" .jpg)
              ./target/release/rust-img-optimizer convert --input "$img" --output "../../data/images/${base}.webp" --format webp --quality 75 --max-width 640 2>/dev/null || true
            fi
          done

      - name: Upload Images to R2 with 2-Version Rotation
        run: |
          echo "ðŸ“¤ Uploading with 2-version rotation..."
          for webp in data/images/*.webp; do
            if [ -f "$webp" ]; then
              base=$(basename "$webp")
              
              # V14.5.7: Backup existing to v-1 before overwrite (2-version rolling)
              echo "ðŸ”„ Rotating $base -> ${base%.*}.v-1.webp"
              wrangler r2 object copy $R2_BUCKET/images/$base $R2_BUCKET/images/${base%.*}.v-1.webp || echo "No existing version for $base"
              
              # Upload new version
              wrangler r2 object put $R2_BUCKET/images/$base --file="$webp" --content-type="image/webp"
            fi
          done
          echo "âœ… Image processing and rotation complete"

      - name: Summary
        run: |
          echo "## ðŸ–¼ï¸ Image Processor Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -f "data/image-results.json" ]; then
            cat data/image-results.json >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          WEBP_COUNT=$(ls -1 data/images/*.webp 2>/dev/null | wc -l)
          echo "- WebP images created: $WEBP_COUNT" >> $GITHUB_STEP_SUMMARY
