---
export const prerender = false;

import Layout from '../../layouts/Layout.astro';
import ModelHero from '../../components/ModelHero.astro';
import TabbedContent from '../../components/TabbedContent.astro';
import ModelCarousel from '../../components/ModelCarousel.astro';
import { getModelBySlug } from '../../utils/db';

const { slug } = Astro.params;

// åˆå§‹åŒ–å˜é‡ï¼Œé˜²æ­¢ undefined é”™è¯¯
let model = null;
let relatedModels = [];
let relatedIds = [];
let error = null;
let pageTitle = "AI Model Details";
let pageDescription = "View details for this AI model.";

// --- é˜¶æ®µ 1: æ•°æ®è·å–ä¸é˜²å¾¡æ€§è§£æ ---
try {
  if (!slug) {
    throw new Error("No slug provided");
  }

  // è·å–åŸå§‹æ•°æ®
  const result = await getModelBySlug(slug, Astro.locals);
  
  if (result) {
    model = result;
    
    // [é˜²å¾¡æ€§æ£€æŸ¥ 1] ç¡®ä¿ model æ˜¯å¯¹è±¡
    if (typeof model !== 'object') {
       console.error("Critical: Model is not an object:", model);
       model = null;
    } else {
        // [é˜²å¾¡æ€§æ£€æŸ¥ 2] å¤„ç† description (é˜²æ­¢å®ƒæ˜¯å¯¹è±¡)
        if (typeof model.description !== 'string') {
            // å¦‚æœæ˜¯å¯¹è±¡åˆ™è½¬å­—ç¬¦ä¸²ï¼Œå¦‚æœæ˜¯ null åˆ™ç»™ç©ºä¸²
            model.description = model.description ? String(model.description) : ""; 
        }

        // [é˜²å¾¡æ€§æ£€æŸ¥ 3] å¤„ç† related_ids
        // Parse related_ids JSON string to array of strings
        if (model.related_ids) {
            try {
                const parsed = JSON.parse(model.related_ids);
                if (Array.isArray(parsed)) {
                    relatedIds = parsed;
                }
            } catch (e) {
                console.warn("Failed to parse related_ids JSON:", e);
                relatedIds = [];
            }
        }
    }
        
    // ğŸ”¥ SMART FALLBACK: If no related_ids (explicit), get top models in same category
    // Only fetch fallback if we don't have explicit IDs
    if (relatedIds.length === 0 && model.pipeline_tag) {
        try {
            const db = Astro.locals?.runtime?.env?.DB;
            if (db) {
                const stmt = db.prepare(`
                    SELECT id, name, author, likes, downloads, cover_image_url, description 
                    FROM models 
                    WHERE pipeline_tag = ? AND id != ?
                    ORDER BY downloads DESC 
                    LIMIT 6
                `);
                const { results } = await stmt.bind(model.pipeline_tag, model.id).all();
                relatedModels = results || [];
                console.log(`Smart fallback: Found ${relatedModels.length} related models for ${model.pipeline_tag}`);
            }
        } catch (fallbackErr) {
            console.warn("Smart fallback failed:", fallbackErr);
        }
    }
  }
} catch (e) {
  console.error("SSR Error fetching model:", e);
  error = e.message;
  // æ³¨æ„ï¼šè¿™é‡Œä¸ return error å¯¹è±¡ï¼Œè€Œæ˜¯å…è®¸é¡µé¢ç»§ç»­æ¸²æŸ“ï¼ˆæ˜¾ç¤ºé”™è¯¯æç¤ºæˆ–404ï¼‰
}

// --- é˜¶æ®µ 2: è·¯ç”±æ§åˆ¶ (å”¯ä¸€çš„ return ç‚¹) ---
// CRITICAL: Validate model has required properties, not just truthy check
// D1's .first() may return {} instead of null when no rows match
if (!model || typeof model !== 'object' || !model.id || !model.name) {
  console.error(`Model validation failed for slug: ${slug}`, {
    hasModel: !!model,
    modelType: typeof model,
    hasId: !!(model?.id),
    hasName: !!(model?.name),
    modelKeys: model ? Object.keys(model) : []
  });
  return new Response(null, {
    status: 404,
    statusText: 'Not Found'
  });
}

// --- é˜¶æ®µ 3: å¸ƒå±€å‚æ•°å®‰å…¨ç”Ÿæˆ ---
// ç¡®ä¿ä¼ å…¥ Layout çš„ç»å¯¹æ˜¯å­—ç¬¦ä¸²ï¼Œæœç» [object Object]
pageTitle = typeof model.name === 'string' && model.name.trim() !== ''
    ? `${model.name} - AI Nexus`
    : "AI Model Details - AI Nexus";

pageDescription = typeof model.description === 'string' 
    ? model.description.substring(0, 160).replace(/[\n\r]/g, ' ') + "..."
    : "Explore this AI model on AI Nexus.";

// [è°ƒè¯•æ¢é’ˆ] è¾“å‡ºæœ€ç»ˆä¼ ç»™æ¨¡æ¿çš„æ•°æ®ç±»å‹
console.log('RENDER CHECK:', {
    slug,
    modelNameType: typeof model.name,
    descType: typeof model.description,
    pageTitle,
    relatedCount: Array.isArray(relatedModels) ? relatedModels.length : 'Not Array'
});

// --- é˜¶æ®µ 4: ç”Ÿæˆ links_data (ä¸´æ—¶æ–¹æ¡ˆï¼Œåç»­ä»DBè·å–) ---
// Generate links JSON from available data
const linksData = JSON.stringify({
  source_url: model.source_url || `https://huggingface.co/${model.id}`,
  docs_url: model.docs_url || (model.source_url ? `${model.source_url}#readme` : ''),
  demo_url: model.demo_url || ''
});
---

<Layout title={pageTitle} description={pageDescription}>
  <main class="container mx-auto px-4 py-8">
    
    {/* é”™è¯¯å±•ç¤ºåŒº */}
    {error && (
        <div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
            <p>System Error: {error}</p>
        </div>
    )}

    <article class="lg:prose-xl mx-auto">
      {/* Hero Section with CTAs - Priority ğŸ¥‡ */}
      <ModelHero 
        name={model.name}
        description={model.description}
        author={model.author}
        likes={Number(model.likes || 0)}
        downloads={Number(model.downloads || 0)}
        pipelineTag={model.pipeline_tag}
        linksData={linksData}
        lastUpdated={model.last_updated}
        license={model.license}
      />

      {/* Tabbed Content Section */}
      <TabbedContent
        overview={model.description || ""}
        quickStart={model.quick_start || ""}
        useCases={model.use_cases || ""}
        resources={model.resources || ""}
      />

      {/* ç›¸å…³æ¨èåŒº - Priority ğŸ¥‰ */}
      <div class="mt-12">
        <h2 class="text-2xl font-bold mb-6">Related Models</h2>
        {/* Pass explicit IDs if available, otherwise pass fallback models */}
        <ModelCarousel 
            ids={relatedIds} 
            initialModels={relatedModels} 
        />
      </div>
    </article>
  </main>
</Layout>
