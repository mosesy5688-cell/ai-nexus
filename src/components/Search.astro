---
// src/components/Search.astro
import ModelCard from './ModelCard.astro';
import type { Model } from '../lib/data';
---

<div id="search-component" class="relative w-full max-w-3xl mx-auto mb-12">
  <div class="relative">
    <input 
      type="search" 
      id="search-input" 
      placeholder="Search for models like 'Llama', 'TTS', 'image generation'..."
      class="w-full px-5 py-4 text-lg text-gray-800 dark:text-gray-200 bg-white dark:bg-gray-800 border-2 border-gray-300 dark:border-gray-600 rounded-full focus:ring-4 focus:ring-blue-300 dark:focus:ring-blue-800 focus:border-blue-500 dark:focus:border-blue-500 outline-none transition-all duration-300 shadow-sm"
    />
    <div id="search-spinner" class="absolute right-5 top-1/2 -translate-y-1/2 hidden animate-spin">
      <svg class="w-6 h-6 text-gray-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </div>
  </div>
  <div id="search-results-container" class="mt-8">
    <!-- Search results will be injected here -->
  </div>
</div>

<!-- This is a template for client-side rendering. It will be cloned. -->
<div id="model-card-template" class="hidden">
    <ModelCard model={{ id: 'template', name: 'Template', source: '#', task: '', tags: [], likes: 0, downloads: 0, lastModified: '' }} />
</div>

<script>
  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const resultsContainer = document.getElementById('search-results-container');
  const spinner = document.getElementById('search-spinner');
  let models: any[] = [];
  let fetchController: AbortController | null = null;

  // Debounce function to limit how often the search function is called
  function debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {
    let timeout: ReturnType<typeof setTimeout> | null = null;

    return (...args: Parameters<F>): Promise<ReturnType<F>> =>
      new Promise(resolve => {
        if (timeout) {
          clearTimeout(timeout);
        }

        timeout = setTimeout(() => resolve(func(...args)), waitFor);
      });
  }

  async function performSearch() {
    if (fetchController) {
      fetchController.abort();
    }
    fetchController = new AbortController();

    const query = searchInput.value.toLowerCase().trim();

    if (query.length < 2) {
      resultsContainer.innerHTML = '';
      spinner.classList.add('hidden');
      return;
    }

    spinner.classList.remove('hidden');

    // Fetch models only when a search is initiated for the first time
    if (models.length === 0) {
      try {
        const response = await fetch('/models.json', { signal: fetchController.signal });
        models = await response.json();
      } catch (error) {
        if (error.name === 'AbortError') {
          console.log('Fetch aborted');
        } else {
          console.error('Failed to fetch models:', error);
        }
        spinner.classList.add('hidden');
        return;
      }
    }

    const filteredModels = models.filter(model => {
      const name = model.name?.toLowerCase() || '';
      const description = model.description?.toLowerCase() || '';
      const task = model.task?.toLowerCase() || '';
      const tags = (model.tags || []).join(' ').toLowerCase();
      
      return name.includes(query) || description.includes(query) || task.includes(query) || tags.includes(query);
    }).slice(0, 10); // Limit to top 10 results for performance

    renderResults(filteredModels);
    spinner.classList.add('hidden');
  }

  function renderResults(results: Model[]) {
    if (results.length === 0) {
      resultsContainer.innerHTML = `
        <div class="text-center p-12 bg-gray-50 dark:bg-gray-800 rounded-lg shadow-inner">
          <p class="text-xl text-gray-500 dark:text-gray-400">No models found for your query.</p>
        </div>
      `;
      return;
    }

    const template = document.getElementById('model-card-template')?.firstElementChild;
    if (!template) return;

    const grid = document.createElement('div');
    grid.className = 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6';

    results.forEach(model => {
      const cardClone = template.cloneNode(true) as HTMLElement;
      // Set the correct href for the link
      const modelUrl = `/model/${model.id.replace(/\//g, '--')}`;
      cardClone.setAttribute('href', modelUrl);
      
      const titleEl = cardClone.querySelector('h2');
      if (titleEl) titleEl.textContent = model.name;

      const platformEl = cardClone.querySelector('.whitespace-nowrap');
      if (platformEl) {
        platformEl.textContent = model.sourcePlatform || '';
        platformEl.className = `text-xs font-bold px-2 py-1 rounded-full whitespace-nowrap ${model.sourcePlatform === 'Civitai' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'}`;
      }

      const pElements = cardClone.querySelectorAll('p');
      if (pElements[0]) pElements[0].innerHTML = `Task: <span class="font-medium text-gray-700 dark:text-gray-300 capitalize">${model.task?.replace(/-/g, ' ') || 'General'}</span>`;
      if (pElements[1]) pElements[1].textContent = model.description || 'No description available.';

      const authorEl = cardClone.querySelector('.mt-4 > span');
      if(authorEl) authorEl.textContent = `By ${model.author || 'Community'}`;

      grid.appendChild(cardClone);
    });

    resultsContainer.innerHTML = '';
    resultsContainer.appendChild(grid);

    // Re-attach event listeners for the newly created buttons
    // This dispatches a custom event that the layout script can listen for.
    document.dispatchEvent(new CustomEvent('ai-nexus:search-results-rendered', {
      detail: { models: results }
    }));
  }

  const debouncedSearch = debounce(performSearch, 300);
  searchInput.addEventListener('input', debouncedSearch);

  // Hide results when clicking outside
  document.addEventListener('click', (e) => {
    if (!document.getElementById('search-component')?.contains(e.target as Node)) {
      resultsContainer.innerHTML = '';
    }
  });
</script>