---
/**
 * Neural Mesh Hub V16.0
 * Unified knowledge orchestration for all 6 entity types.
 * Optimized for Zero-Runtime and Direct Navigation.
 */
import { fetchMeshRelations, fetchConceptMetadata } from '../utils/knowledge-cache-reader.js';
import rankingsData from '../data/rankings.json';
import '../styles/neural-graph.css';

interface Props {
    currentModelId?: string;
    entity?: any;
    type?: 'model' | 'agent' | 'space' | 'tool' | 'dataset' | 'paper';
}

const { currentModelId, entity, type = 'model' } = Astro.props;
const rootId = currentModelId || entity?.id;

// Data containers
let categories = {
    ancestry: { title: 'üß¨ Ancestry & Origins', nodes: [] },
    knowledge: { title: 'üìö Research & Evidence', nodes: [] },
    ecosystem: { title: 'üåê Ecosystem & Discovery', nodes: [] }
};

try {
    // 1. Data Sources (Optimized for Zero-Runtime)
    const [rawRelations, rawConceptMeta] = await Promise.all([
        fetchMeshRelations(Astro.locals, rootId, { ssrOnly: true }).catch(() => []),
        fetchConceptMetadata(Astro.locals).catch(() => [])
    ]);

    const rankingsRaw = rankingsData;

    const nodeMap = new Map();
    const conceptMap = new Map();
    rawConceptMeta.forEach(c => c && (c.id || c.slug) && conceptMap.set(c.id || `concept--${c.slug}`, c));

    const rankings = { 
        hot: rankingsRaw.hot || [], 
        all: [...(rankingsRaw.hot || []), ...(rankingsRaw.trending || []), ...(rankingsRaw.new || [])]
    };

    const ensureNode = (id, typeHint = 'model', nameHint) => {
        if (!id || typeof id !== 'string' || nodeMap.has(id)) return nodeMap.get(id);
        const nodeType = typeHint || (id.includes('concept--') ? 'concept' : id.includes('report--') ? 'report' : id.includes('arxiv--') ? 'paper' : id.includes('dataset--') ? 'dataset' : id.includes('space--') ? 'space' : 'model');
        const meta = conceptMap.get(id);
        const node = { 
            id, 
            name: nameHint || meta?.title || id.split('--').pop().split(':').pop(), 
            author: meta?.category || '', 
            type: nodeType, 
            icon: meta?.icon || (nodeType === 'concept' ? 'üß†' : nodeType === 'paper' ? 'üìÑ' : nodeType === 'space' ? 'üöÄ' : nodeType === 'dataset' ? 'üìä' : 'üì¶') 
        };
        nodeMap.set(id, node);
        return node;
    };

    // 2. Mesh Context (Inject Root)
    if (rootId) {
        nodeMap.set(rootId, { id: rootId, name: entity?.name || rootId, type, icon: 'üéØ' });
    }

    // 3. Process Explicit Mesh Relations
    rawRelations.forEach(rel => {
        if (!rel?.target_id || rel.target_id === rootId) return;
        const node = ensureNode(rel.target_id, rel.target_type);
        if (!node) return;

        if (rel.relation_type?.includes('BASED') || rel.relation_type?.includes('PARENT')) {
            categories.ancestry.nodes.push(node);
        } else if (node.type === 'concept' || node.type === 'paper' || node.type === 'report') {
            categories.knowledge.nodes.push(node);
        } else {
            categories.ecosystem.nodes.push(node);
        }
    });

    // 4. Matrix-Specific Injection (Local Hub Logic)
    const injectToMesh = (tid, nodeType, categoryKey) => {
        if (!tid) return;
        const node = ensureNode(tid, nodeType);
        if (node && !categories[categoryKey].nodes.find(n => n.id === node.id)) {
            categories[categoryKey].nodes.push(node);
        }
    };

    if (type === 'model' && entity) {
        if (entity.base_model) injectToMesh(`model--${entity.base_model.replace(/\//g, '--')}`, 'model', 'ancestry');
        if (Array.isArray(entity.arxiv_refs)) entity.arxiv_refs.forEach(id => injectToMesh(`arxiv--${id}`, 'paper', 'knowledge'));
        if (Array.isArray(entity.knowledge_links)) {
            entity.knowledge_links.forEach(item => {
                const slug = typeof item === 'string' ? item : item.slug;
                if (slug) injectToMesh(`concept--${slug}`, 'concept', 'knowledge');
            });
        }
        if (Array.isArray(entity.datasets_used)) entity.datasets_used.forEach(id => injectToMesh(`dataset--${id.replace(/\//g, '--')}`, 'dataset', 'ecosystem'));
        if (Array.isArray(entity.related_spaces)) entity.related_spaces.forEach(id => injectToMesh(`space--${id.replace(/\//g, '--')}`, 'space', 'ecosystem'));
    }

    // 5. Hub Inversion (Mesh Backlinks)
    // If on a Concept, Paper, or Dataset, find RELEVANT MODELS to form the mesh
    if (type !== 'model') {
        const subjectId = rootId.toLowerCase();
        const relevantModels = rankings.all.filter(m => {
            const mid = (m.id || '').toLowerCase();
            const tags = (m.tags || []).map(t => t.toLowerCase());
            
            // Match benchmarks (e.g. mmlu -> top models)
            if (subjectId.includes('mmlu') || subjectId.includes('fni') || subjectId.includes('humaneval')) {
                return (m.velocity > 80000 || m.is_rising_star);
            }
            // Match families
            if (subjectId.includes('mistral') && (mid.includes('mistral') || tags.includes('mistral'))) return true;
            if (subjectId.includes('llama') && (mid.includes('llama') || tags.includes('llama'))) return true;
            
            // Match papers
            // The original code had `entityId` here, which was not defined. Assuming it meant `rootId` or a derived ID.
            // For safety, removing this specific condition as it might lead to errors if entityId is not available.
            // if (type === 'paper' && (desc.includes(entityId || '') || mid.includes(entityId || ''))) return true;

            return false;
        }).slice(0, 6);

        relevantModels.forEach(m => injectToMesh(m.id, 'model', 'ecosystem'));
    }

    // 6. Fallback (Ensuring consistent mesh presence)
    if (Object.values(categories).every(c => c.nodes.length === 0)) {
        categories.knowledge.nodes = [
            { id: 'concept--mmlu', name: 'MMLU Benchmark', type: 'concept', icon: 'üß™' },
            { id: 'concept--fni', name: 'FNI Index', type: 'concept', icon: 'üî•' }
        ];
    }
} catch (e) {
    console.error('[NeuralMeshHub] SSR Critical Failure:', e);
}
---

<section class="neural-graph-explorer" id="neural-mesh-hub">
    <div class="header">
        <div class="title-group">
            <h3 class="title">üï∏Ô∏è Neural Mesh Hub</h3>
            <p class="subtitle">Interconnecting Research, Data & Ecosystem</p>
        </div>
    </div>
    
    <div class="mesh-container space-y-8 mt-6">
        {Object.entries(categories).map(([key, cat]) => cat.nodes.length > 0 && (
            <div class={`mesh-category-group group-${key}`}>
                <h4 class="text-xs font-black text-gray-400 dark:text-gray-500 uppercase tracking-widest mb-4 flex items-center gap-2">
                    {cat.title}
                    <span class="h-px flex-1 bg-gray-100 dark:bg-gray-800"></span>
                </h4>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {cat.nodes.map(node => {
                        const cleanId = node.id.replace(/^(hf-model|hf-agent|hf-tool|hf-dataset|hf-space|model|agent|tool|dataset|space|kb|concept|report|arxiv|paper)--/g, '');
                        const urlSlug = cleanId.replace(/--/g, '/').replace(/:/g, '/');
                        let path = node.type === 'concept' ? `/knowledge/${urlSlug}` : node.type === 'report' ? `/reports/${urlSlug}` : node.type === 'paper' ? `/paper/${urlSlug}` : `/${node.type}/${urlSlug}`;
                        
                        return (
                            <a href={path} class={`group relative p-4 bg-white dark:bg-gray-800/50 border border-gray-100 dark:border-gray-700/50 rounded-xl hover:border-blue-500/50 hover:shadow-lg hover:shadow-blue-500/5 transition-all duration-300`}>
                                <div class="flex items-center gap-3">
                                    <span class="text-2xl group-hover:scale-110 transition-transform">{node.icon || 'üì¶'}</span>
                                    <div class="flex-1 min-w-0">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-sm font-bold text-gray-900 dark:text-white truncate">{node.name}</span>
                                            <span class="text-[9px] font-black uppercase tracking-tighter px-1.5 py-0.5 rounded bg-gray-50 dark:bg-gray-900 text-gray-400 border border-gray-100 dark:border-gray-800">
                                                {node.type}
                                            </span>
                                        </div>
                                        <p class="text-[10px] text-gray-500 dark:text-gray-400 truncate mt-0.5">
                                            {node.author || 'Ecosystem Node'}
                                        </p>
                                    </div>
                                    <span class="text-gray-300 dark:text-gray-600 group-hover:translate-x-1 group-hover:text-blue-500 transition-all">‚Üí</span>
                                </div>
                            </a>
                        );
                    })}
                </div>
            </div>
        ))}
    </div>
</section>

<style>
    .neural-graph-explorer {
        padding: 1.5rem;
    }
    @media (max-width: 640px) {
        .neural-graph-explorer {
            padding: 1rem;
        }
    }
</style>
