---
/**
 * Neural Mesh Hub V16.2
 * Unified knowledge orchestration for all 6 entity types.
 * Optimized for Zero-Runtime and Bidirectional Discovery.
 */
import { fetchMeshRelations, fetchGraphMetadata, stripPrefix } from '../utils/knowledge-cache-reader.js';
import rankingsData from '../data/rankings.json';
import '../styles/neural-graph.css';

interface Props {
    currentModelId?: string;
    entity?: any;
    type?: string;
}

const { currentModelId, entity, type = 'model' } = Astro.props;
const rootId = currentModelId || entity?.id;
const normRoot = stripPrefix(rootId);

// Data containers
let categories = {
    ancestry: { title: 'üß¨ Ancestry & Origins', nodes: [] },
    knowledge: { title: 'üìö Research & Evidence', nodes: [] },
    ecosystem: { title: 'üåê Ecosystem & Discovery', nodes: [] },
    similar: { title: 'üë• Similar Entities', nodes: [] }
};

try {
    const [rawRelations, graphMeta] = await Promise.all([
        fetchMeshRelations(Astro.locals, rootId, { ssrOnly: true }).catch(() => []),
        fetchGraphMetadata(Astro.locals).catch(() => ({}))
    ]);

    const nodeMap = new Map();
    const seenIds = new Set();
    if (normRoot) seenIds.add(normRoot);

    const ensureNode = (id, typeHint = 'model') => {
        const nid = id;
        const norm = stripPrefix(nid);
        if (seenIds.has(norm)) return nodeMap.get(norm);
        
        const meta = graphMeta[nid] || {};
        const nodeType = meta.t || typeHint || (
            nid.includes('concept--') || nid.includes('knowledge--') || nid.includes('kb--') ? 'concept' : 
            nid.includes('arxiv--') ? 'paper' : 
            nid.includes('dataset--') ? 'dataset' : 
            nid.includes('space--') ? 'space' : 
            nid.includes('agent--') ? 'agent' : 
            nid.includes('tool--') ? 'tool' : 
            'model'
        );
        const parts = nid.split('--');
        const nodeAuthor = meta.author || (parts.length > 2 ? parts[parts.length-2].replace(/-/g, ' ') : (nid.startsWith('arxiv--') || nid.startsWith('paper--')) ? 'Research Paper' : (nid.startsWith('concept--') || nid.startsWith('knowledge--') || nid.startsWith('kb--')) ? 'AI Knowledge Base' : 'Ecosystem Node');
        
        const node = { 
            id: nid, 
            name: meta.n || nid.split('--').pop().replace(/-/g, ' ').toUpperCase(), 
            type: nodeType, 
            icon: meta.icon || (nodeType === 'concept' ? 'üß†' : nodeType === 'paper' ? 'üìÑ' : nodeType === 'space' ? 'üöÄ' : nodeType === 'dataset' ? 'üìä' : nodeType === 'agent' ? 'ü§ñ' : nodeType === 'tool' ? 'üõ†Ô∏è' : 'üì¶'),
            author: nodeAuthor,
            hub: meta.hub || false
        };
        nodeMap.set(norm, node);
        seenIds.add(norm);
        return node;
    };

    // Process Bidirectional Mesh
    rawRelations.forEach(rel => {
        const isOut = rel.norm_source === normRoot;
        const isIn = rel.norm_target === normRoot;
        if (!isOut && !isIn) return;

        const neighborId = isOut ? rel.target_id : rel.source_id;
        const node = ensureNode(neighborId, isOut ? rel.target_type : rel.source_type);
        if (!node) return;

        // Categorize based on relation type and node type
        const rType = (rel.relation_type || '').toUpperCase();
        
        // Define relation-specific icons
        const relIcons = {
            'BASED_ON': 'üß¨',
            'TRAINED_ON': 'üìä',
            'CITES': 'üìÑ',
            'STACK': 'üõ†Ô∏è',
            'EXPLAIN': 'üß†',
            'USES': '‚öôÔ∏è',
            'DEMO_OF': 'üöÄ',
            'POWERED_BY': '‚ö°',
            'DEP': 'üì¶'
        };
        
        if (relIcons[rType]) node.icon = relIcons[rType];

        if (rType.includes('ALT') || rType.includes('SIMILAR') || rType === 'ALTERNATIVE') {
            categories.similar.nodes.push(node);
        } else if (rType === 'BASED_ON' || rType === 'PARENT' || rType === 'TRAINED_ON') {
            categories.ancestry.nodes.push(node);
        } else if (rType === 'CITES' || rType === 'EXPLAIN' || rType === 'IMPLEMENTS' || rType === 'RESEARCH' || node.type === 'concept' || node.type === 'paper') {
            categories.knowledge.nodes.push(node);
        } else {
            categories.ecosystem.nodes.push(node);
        }
    });

    // Matrix-Specific Injection (Local Hub Logic as Fallback/Augment)
    if (type === 'model' && entity) {
        if (entity.base_model) {
            const node = ensureNode(`hf-model--${entity.base_model.replace(/\//g, '--')}`, 'model');
            if (node && !categories.ancestry.nodes.find(n => n.id === node.id)) categories.ancestry.nodes.push(node);
        }
        if (Array.isArray(entity.knowledge_links)) {
            entity.knowledge_links.forEach(l => {
                const slug = typeof l === 'string' ? l : l.slug;
                const node = ensureNode(`concept--${slug}`, 'concept');
                if (node && !node.name && typeof l !== 'string' && l.title) node.name = l.title;
                if (node && !categories.knowledge.nodes.find(n => n.id === node.id)) categories.knowledge.nodes.push(node);
            });
        }
        if (Array.isArray(entity.arxiv_refs)) {
            entity.arxiv_refs.forEach(id => {
                const node = ensureNode(`arxiv--${id}`, 'paper');
                if (node && !categories.knowledge.nodes.find(n => n.id === node.id)) categories.knowledge.nodes.push(node);
            });
        }
        if (Array.isArray(entity.datasets_used)) {
            entity.datasets_used.forEach(id => {
                const node = ensureNode(`dataset--${id}`, 'dataset');
                if (node && !categories.ecosystem.nodes.find(n => n.id === node.id)) categories.ecosystem.nodes.push(node);
            });
        }
    }

    // Default Fallback for empty mesh
    if (Object.values(categories).every(c => c.nodes.length === 0)) {
        categories.knowledge.nodes = [
            { id: 'concept--mmlu', name: 'MMLU Benchmark', type: 'concept', icon: 'üß™' },
            { id: 'concept--fni', name: 'FNI Index', type: 'concept', icon: 'üî•' }
        ];
    }
} catch (e) {
    console.error('[NeuralMeshHub] SSR Error:', e);
}
---

<section class="neural-graph-explorer" id="neural-mesh-hub">
    <div class="header">
        <div class="title-group">
            <h3 class="title">üï∏Ô∏è Neural Mesh Hub</h3>
            <p class="subtitle">Interconnecting Research, Data & Ecosystem</p>
        </div>
    </div>
    
    <div class="mesh-container space-y-8 mt-6">
        {Object.entries(categories).map(([key, cat]) => cat.nodes.length > 0 && (
            <div class={`mesh-category-group group-${key}`}>
                <h4 class="text-xs font-black text-gray-400 dark:text-gray-500 uppercase tracking-widest mb-4 flex items-center gap-2">
                    {cat.title}
                    <span class="h-px flex-1 bg-gray-100 dark:bg-gray-800"></span>
                </h4>
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                    {cat.nodes.map(node => {
                        const cleanId = node.id.replace(/^(hf-model|hf-agent|hf-tool|hf-dataset|hf-space|model|agent|tool|dataset|space|kb|concept|knowledge|report|arxiv|paper|huggingface|huggingface_deepspec|github|replicate)[:\-]+/, '')
                                              .replace(/^(hf-model|hf-agent|hf-tool|hf-dataset|hf-space|huggingface_deepspec|knowledge|kb)--/, '');
                        const urlSlug = cleanId.replace(/--/g, '/').replace(/:/g, '/');
                        let path = node.type === 'concept' ? `/knowledge/${urlSlug}` : node.type === 'report' ? `/reports/${urlSlug}` : node.type === 'paper' ? `/paper/${urlSlug}` : `/${node.type}/${urlSlug}`;
                        
                        return (
                            <a href={path} class={`group relative p-4 bg-white dark:bg-gray-800/50 border border-gray-100 dark:border-gray-700/50 rounded-xl hover:border-blue-500/50 hover:shadow-lg hover:shadow-blue-500/5 transition-all duration-300`}>
                                <div class="flex items-center gap-3">
                                    <span class="text-2xl group-hover:scale-110 transition-transform">{node.icon || 'üì¶'}</span>
                                    <div class="flex-1 min-w-0">
                                        <div class="flex items-center justify-between gap-2">
                                            <span class="text-sm font-bold text-gray-900 dark:text-white truncate">{node.name}</span>
                                            <span class="text-[9px] font-black uppercase tracking-tighter px-1.5 py-0.5 rounded bg-gray-50 dark:bg-gray-900 text-gray-400 border border-gray-100 dark:border-gray-800">
                                                {node.type}
                                            </span>
                                        </div>
                                        <p class="text-[10px] text-gray-500 dark:text-gray-400 truncate mt-0.5">
                                            {node.author || 'Ecosystem Node'}
                                        </p>
                                    </div>
                                    <span class="text-gray-300 dark:text-gray-600 group-hover:translate-x-1 group-hover:text-blue-500 transition-all">‚Üí</span>
                                </div>
                            </a>
                        );
                    })}
                </div>
            </div>
        ))}
    </div>
</section>

<style>
    .neural-graph-explorer {
        padding: 1.5rem;
    }
    @media (max-width: 640px) {
        .neural-graph-explorer {
            padding: 1rem;
        }
    }
</style>
