---
/**
 * Neural Mesh Hub V16.2
 * Unified knowledge orchestration for all 6 entity types.
 * Optimized for Zero-Runtime and Bidirectional Discovery.
 */
import { fetchMeshRelations, fetchGraphMetadata, stripPrefix, isMatch, getRouteFromId } from '../utils/knowledge-cache-reader.js';
import rankingsData from '../data/rankings.json';
import '../styles/neural-graph.css';

interface Props {
    currentModelId?: string;
    entity?: any;
    type?: string;
}

const { currentModelId, entity, type = 'model' } = Astro.props;
const rootId = currentModelId || entity?.id;
const normRoot = stripPrefix(rootId);

// 4-Tier Topology
let tiers = {
    explanation: { title: 'üß† Theoretical Foundation', nodes: [], icon: 'üß†', zone: 'Z3.1' },
    core: { title: 'üíé Core Ecosystem', nodes: [], icon: '‚ö°', zone: 'Z3.2' }, 
    utility: { title: 'üî¨ Applied Research', nodes: [], icon: 'üî¨', zone: 'Z3.3' }, 
    digest: { title: 'üì∞ Timeline & Reports', nodes: [], icon: 'üì∞', zone: 'Z3.4' }
};


try {
    const [rawRelations, graphMeta, knowledgeIndex] = await Promise.all([
        fetchMeshRelations(Astro.locals, rootId, { ssrOnly: true }).catch(() => []),
        fetchGraphMetadata(Astro.locals).catch(() => ({})),
        Promise.resolve().then(async () => {
            const r2 = Astro.locals?.runtime?.env?.R2_ASSETS;
            if (!r2) return { articles: [] };
            try {
                const obj = await r2.get('cache/knowledge/index.json');
                return obj ? await obj.json() : { articles: [] };
            } catch (e) {
                return { articles: [] };
            }
        })
    ]);

    const articles = knowledgeIndex?.articles || [];
    const validSlugs = new Set(articles.map((a: any) => a.slug));

    const nodeMap = new Map();
    const seenIds = new Set();
    if (normRoot) seenIds.add(normRoot);

    const ensureNode = (id, typeHint = 'model') => {
        const nid = id;
        const norm = stripPrefix(nid);
        if (seenIds.has(norm)) return nodeMap.get(norm);
        
        const meta = graphMeta[nid] || {};
        const nodeType = meta.t || typeHint || (
            nid.includes('knowledge--') || nid.includes('kb--') ? 'knowledge' : 
            nid.includes('arxiv--') ? 'paper' : 
            nid.includes('report--') ? 'report' :
            nid.includes('dataset--') ? 'dataset' : 
            nid.includes('space--') ? 'space' : 
            nid.includes('agent--') ? 'agent' : 
            nid.includes('tool--') ? 'tool' : 
            'model'
        );
        const parts = nid.split('--');
        const nodeAuthor = meta.author || (parts.length > 2 ? parts[parts.length-2].replace(/-/g, ' ') : (nid.startsWith('arxiv--') || nid.startsWith('paper--')) ? 'Research Paper' : (nid.startsWith('knowledge--') || nid.startsWith('kb--')) ? 'AI Knowledge Base' : 'Ecosystem Node');
        
        const node = { 
            id: nid, 
            name: meta.n || nid.split('--').pop().replace(/-/g, ' ').toUpperCase(), 
            type: nodeType, 
            icon: meta.icon || (nodeType === 'knowledge' ? 'üß†' : nodeType === 'paper' ? 'üìÑ' : nodeType === 'space' ? 'üöÄ' : nodeType === 'dataset' ? 'üìä' : nodeType === 'agent' ? 'ü§ñ' : nodeType === 'tool' ? 'üõ†Ô∏è' : nodeType === 'report' ? 'üì∞' : 'üì¶'),
            author: nodeAuthor,
            hub: meta.hub || false,
            relation: '' // Explicit relation label
        };
        nodeMap.set(norm, node);
        seenIds.add(norm);
        return node;
    };

    // Unified Global Node Registry (Prevents Duplication)
    const nodeRegistry = new Map();

    // Process Bidirectional Mesh
    rawRelations.forEach(rel => {
        const isOut = isMatch(rel.norm_source, normRoot);
        const isIn = isMatch(rel.norm_target, normRoot);
        if (!isOut && !isIn) return;

        const neighborId = isOut ? rel.target_id : rel.source_id;
        const normNeighbor = stripPrefix(neighborId);
        
        // Circular Reference Protection
        if (normNeighbor === normRoot) return;

        // V16.4: Zero-404 & De-Duplication Policy
        let finalNeighborId = neighborId;
        if (neighborId.startsWith('knowledge--')) {
            // Mapping is now handled inside getRouteFromId
            finalNeighborId = neighborId;
        }

        const finalNorm = stripPrefix(finalNeighborId);
        let node = nodeRegistry.get(finalNorm);
        if (!node) {
            node = ensureNode(finalNeighborId, isOut ? rel.target_type : rel.source_type);
            nodeRegistry.set(finalNorm, node);
        }

        // Relation Affinity Logic
        const rType = (rel.relation_type || 'RELATED').toUpperCase();
        if (!node.relation || node.relation === 'RELATED') {
            node.relation = rType;
        }

        // Tier Assignment
        if (!node._mapped) {
            node._mapped = true;
            if (node.type === 'knowledge') {
                tiers.explanation.nodes.push(node);
            } else if (node.type === 'model' || node.type === 'tool' || node.type === 'dataset' || node.type === 'unknown') {
                tiers.core.nodes.push(node); // Default unknown/unprefixed models to Core
            } else if (node.type === 'agent' || node.type === 'space' || node.type === 'paper') {
                tiers.utility.nodes.push(node);
            } else if (node.type === 'report') {
                tiers.digest.nodes.push(node);
            }
        }
    });

    // Matrix-Specific Injection (V16.4: Enhanced Global Injections)
    if (entity) {
        const inject = (id, typeHint, relType) => {
            if (!id) return;
            const norm = stripPrefix(id);
            if (norm === normRoot) return;
            
            let finalId = id;
            if (id.startsWith('knowledge--')) {
                // Mapping is now handled inside getRouteFromId
                finalId = id;
            }

            const finalNorm = stripPrefix(finalId);
            let node = nodeRegistry.get(finalNorm);
            if (!node) {
                node = ensureNode(finalId, typeHint);
                nodeRegistry.set(finalNorm, node);
            }
            if (!node.relation || node.relation === 'RELATED') node.relation = relType;
            
            if (!node._mapped) {
                node._mapped = true;
                if (node.type === 'knowledge') tiers.explanation.nodes.push(node);
                else if (['model', 'tool', 'dataset', 'unknown'].includes(node.type)) tiers.core.nodes.push(node);
                else if (['agent', 'space', 'paper'].includes(node.type)) tiers.utility.nodes.push(node);
                else if (node.type === 'report') tiers.digest.nodes.push(node);
            }
        };

        // ArXiv & Datasets
        if (Array.isArray(entity.arxiv_refs)) entity.arxiv_refs.forEach(ref => inject(`arxiv--${ref}`, 'paper', 'CITES'));
        if (Array.isArray(entity.datasets_used)) entity.datasets_used.forEach(ds => inject(`dataset--${ds.replace(/\//g, '--')}`, 'dataset', 'TRAINED_ON'));
        if (Array.isArray(entity.similar_models)) entity.similar_models.forEach(m => inject(`model--${m.replace(/\//g, '--')}`, 'model', 'RELATED'));

        // Type-Specific Injections
        if (type === 'model') {
            if (entity.base_model) inject(`hf-model--${entity.base_model.replace(/\//g, '--')}`, 'model', 'BASED_ON');
            if (entity.license) inject(`knowledge--${entity.license.toLowerCase().split(' ')[0]}`, 'knowledge', 'LICENSED');
            if (entity.library_name) inject(`tool--${entity.library_name.toLowerCase()}`, 'tool', 'STACK');
        } else if (type === 'agent' && entity.framework) {
            inject(`tool--${entity.framework.toLowerCase()}`, 'tool', 'STACK');
        } else if (type === 'space') {
            const modelsUsed = entity.meta_json?.models_used || entity.models_used || [];
            modelsUsed.forEach(m => inject(`model--${m.replace(/\//g, '--')}`, 'model', 'USES'));
        }

        // Tags Injection (Fills sparse graphs)
        if (Array.isArray(entity.tags)) {
            entity.tags.slice(0, 5).forEach(tag => {
                const cleanTag = tag.replace(/[^a-zA-Z0-9-]/g, '-').toLowerCase();
                inject(`knowledge--${cleanTag}`, 'knowledge', 'TAGGED');
            });
        }

        // Knowledge Links
        if (Array.isArray(entity.knowledge_links)) {
            entity.knowledge_links.forEach(l => {
                const slug = typeof l === 'string' ? l : l.slug;
                inject(`knowledge--${slug}`, 'knowledge', 'EXPLAINS');
                const norm = stripPrefix(`knowledge--${slug}`);
                if (node && !node.name && typeof l !== 'string' && l.title) node.name = l.title;
            });
        }
    }
    
    // V16.4: Cross-Component Deduplication (Global State)
    if (!Astro.locals.meshRenderedNodes) Astro.locals.meshRenderedNodes = new Set();
    nodeRegistry.forEach((node, norm) => {
        if (node._mapped) {
            Astro.locals.meshRenderedNodes.add(norm);
        }
    });

} catch (e) {
    console.error('[NeuralMeshHub] V16.2 Execution Error:', e);
}

const hasRelations = Object.values(tiers).some(t => t.nodes.length > 0);
---

{hasRelations && (
<div class="neural-graph-wrapper bg-white dark:bg-gray-800 rounded-2xl shadow-sm border border-gray-100 dark:border-gray-700 overflow-hidden">
    <section class="neural-graph-explorer" id="neural-mesh-hub">
        <div class="header">
            <div class="title-group">
                <h3 class="title">üï∏Ô∏è Neural Mesh Hub</h3>
                <p class="subtitle">Interconnecting Research, Data & Ecosystem</p>
            </div>
        </div>
        
        <div class="mesh-container space-y-10 mt-8">
            {Object.entries(tiers).map(([key, tier]) => tier.nodes.length > 0 && (
                <div class={`mesh-tier mesh-tier-${key}`} data-zone={tier.zone}>
                    <div class="tier-header flex items-center gap-3 mb-6">
                        <span class="tier-icon text-xl p-2 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-100 dark:border-gray-800 shadow-sm">
                            {tier.icon}
                        </span>
                        <div class="flex-1">
                            <h4 class="text-xs font-black text-gray-400 dark:text-gray-500 uppercase tracking-[0.2em]">
                                {tier.title}
                            </h4>
                            <div class="h-px w-full bg-gradient-to-r from-gray-100 dark:from-gray-800 to-transparent mt-2"></div>
                        </div>
                    </div>

                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
                        {tier.nodes.map(node => {
                            const path = getRouteFromId(node.id, node.type);
                            
                            return (
                                <a href={path} class={`mesh-node group relative p-4 bg-white dark:bg-gray-800/40 border border-gray-100 dark:border-gray-700/50 rounded-2xl hover:border-indigo-500/50 hover:shadow-xl hover:shadow-indigo-500/5 transition-all duration-300`}>
                                    <div class="flex items-start gap-4">
                                        <div class="node-icon-wrapper relative">
                                            <span class="text-3xl filter grayscale group-hover:grayscale-0 transition-all duration-500 block">
                                                {node.icon || 'üì¶'}
                                            </span>
                                            {node.relation && (
                                                <span class="relation-badge absolute -top-2 -right-2 px-1.5 py-0.5 bg-indigo-500 text-[8px] font-black text-white rounded shadow-sm uppercase tracking-tighter">
                                                    {node.relation}
                                                </span>
                                            )}
                                        </div>
                                        <div class="flex-1 min-w-0">
                                            <div class="flex items-center justify-between gap-2 mb-1">
                                                <span class="text-sm font-bold text-gray-900 dark:text-white truncate group-hover:text-indigo-500 transition-colors">
                                                    {node.name}
                                                </span>
                                                <span class="text-[8px] font-black uppercase tracking-tighter px-1.5 py-0.5 rounded bg-gray-50 dark:bg-gray-900 text-gray-400 border border-gray-100 dark:border-gray-800">
                                                    {node.type}
                                                </span>
                                            </div>
                                            <p class="text-[10px] text-gray-500 dark:text-gray-400 line-clamp-1">
                                                {node.author || 'Ecosystem Node'}
                                            </p>
                                        </div>
                                        <div class="flex flex-col justify-center opacity-30 group-hover:opacity-100 transition-opacity">
                                            <span class="text-indigo-500 translate-x-0 group-hover:translate-x-1 transition-transform">‚Üí</span>
                                        </div>
                                    </div>
                                </a>
                            );
                        })}
                    </div>
                </div>
            ))}
        </div>
    </section>
</div>
)}

<style>
    .neural-graph-explorer {
        padding: 1.5rem;
    }
    @media (max-width: 640px) {
        .neural-graph-explorer {
            padding: 1rem;
        }
    }
</style>
