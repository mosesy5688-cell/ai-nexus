---
/**
 * Neural Mesh Hub V16.2
 * Unified knowledge orchestration for all 6 entity types.
 * Optimized for Zero-Runtime and Bidirectional Discovery.
 */
import { fetchMeshRelations, fetchGraphMetadata, stripPrefix, isMatch } from '../utils/knowledge-cache-reader.js';
import rankingsData from '../data/rankings.json';
import '../styles/neural-graph.css';

interface Props {
    currentModelId?: string;
    entity?: any;
    type?: string;
}

const { currentModelId, entity, type = 'model' } = Astro.props;
const rootId = currentModelId || entity?.id;
const normRoot = stripPrefix(rootId);

// 4-Tier Topology
let tiers = {
    explanation: { title: 'üß† Concept & Explanation', nodes: [], icon: 'üß†', zone: 'Z3.1' },
    core: { title: 'üíé Core Ecosystem', nodes: [], icon: '‚ö°', zone: 'Z3.2' }, 
    utility: { title: 'üîß Utility & Research', nodes: [], icon: 'üõ†Ô∏è', zone: 'Z3.3' }, 
    digest: { title: 'üì∞ Timeline & Reports', nodes: [], icon: 'üì∞', zone: 'Z3.4' }
};

// V16.4: Cross-Source Slug Redirects (Fixes 404s)
const SLUG_MAPPING = {
    'instruction-tuning': 'fine-tuning',
    'image-generation': 'multimodal',
    'chat-models': 'agents',
    'rag-retrieval': 'rag',
    'vector-databases': 'rag',
    'prompt-engineering': 'prompt-engineering',
    'transformer-architecture': 'transformer',
    'direct-preference-optimization': 'fine-tuning',
    'what-is-rag': 'rag',
    'local-deployment': 'local-inference',
    'what-is-quantization': 'quantization',
    'audio-models': 'multimodal',
    'agentic-ai': 'agents',
    'what-is-moe': 'moe',
    'mixture-of-experts': 'moe',
    'lora-finetuning': 'fine-tuning',
    'speech-models': 'multimodal',
    'inference-optimization': 'local-inference',
    'gguf-format': 'gguf',
    'ai-alignment': 'fine-tuning',
    'vision-models': 'multimodal',
    'attention-mechanism': 'transformer'
};

try {
    const [rawRelations, graphMeta, knowledgeIndex] = await Promise.all([
        fetchMeshRelations(Astro.locals, rootId, { ssrOnly: true }).catch(() => []),
        fetchGraphMetadata(Astro.locals).catch(() => ({})),
        Astro.locals.runtime.env.R2_ASSETS.get('cache/knowledge/index.json')
            .then(obj => obj ? obj.json() : { articles: [] })
            .catch(() => ({ articles: [] }))
    ]);

    const validSlugs = new Set(knowledgeIndex.articles.map(a => a.slug));

    const nodeMap = new Map();
    const seenIds = new Set();
    if (normRoot) seenIds.add(normRoot);

    const ensureNode = (id, typeHint = 'model') => {
        const nid = id;
        const norm = stripPrefix(nid);
        if (seenIds.has(norm)) return nodeMap.get(norm);
        
        const meta = graphMeta[nid] || {};
        const nodeType = meta.t || typeHint || (
            nid.includes('knowledge--') || nid.includes('kb--') ? 'knowledge' : 
            nid.includes('arxiv--') ? 'paper' : 
            nid.includes('report--') ? 'report' :
            nid.includes('dataset--') ? 'dataset' : 
            nid.includes('space--') ? 'space' : 
            nid.includes('agent--') ? 'agent' : 
            nid.includes('tool--') ? 'tool' : 
            'model'
        );
        const parts = nid.split('--');
        const nodeAuthor = meta.author || (parts.length > 2 ? parts[parts.length-2].replace(/-/g, ' ') : (nid.startsWith('arxiv--') || nid.startsWith('paper--')) ? 'Research Paper' : (nid.startsWith('knowledge--') || nid.startsWith('kb--')) ? 'AI Knowledge Base' : 'Ecosystem Node');
        
        const node = { 
            id: nid, 
            name: meta.n || nid.split('--').pop().replace(/-/g, ' ').toUpperCase(), 
            type: nodeType, 
            icon: meta.icon || (nodeType === 'knowledge' ? 'üß†' : nodeType === 'paper' ? 'üìÑ' : nodeType === 'space' ? 'üöÄ' : nodeType === 'dataset' ? 'üìä' : nodeType === 'agent' ? 'ü§ñ' : nodeType === 'tool' ? 'üõ†Ô∏è' : nodeType === 'report' ? 'üì∞' : 'üì¶'),
            author: nodeAuthor,
            hub: meta.hub || false,
            relation: '' // Explicit relation label
        };
        nodeMap.set(norm, node);
        seenIds.add(norm);
        return node;
    };

    // Unified Global Node Registry (Prevents Duplication)
    const nodeRegistry = new Map();

    // Process Bidirectional Mesh
    rawRelations.forEach(rel => {
        const isOut = isMatch(rel.norm_source, normRoot);
        const isIn = isMatch(rel.norm_target, normRoot);
        if (!isOut && !isIn) return;

        const neighborId = isOut ? rel.target_id : rel.source_id;
        const normNeighbor = stripPrefix(neighborId);
        
        // Circular Reference Protection
        if (normNeighbor === normRoot) return;

        // V16.4: Zero-404 & De-Duplication Policy
        let finalNeighborId = neighborId;
        if (neighborId.startsWith('knowledge--')) {
            let slug = normNeighbor.split('--').pop();
            // 1. Redirect known broken slugs
            if (SLUG_MAPPING[slug]) slug = SLUG_MAPPING[slug];
            // 2. Hide if still missing from index
            if (!validSlugs.has(slug)) return; 
            finalNeighborId = `knowledge--${slug}`;
        }

        const finalNorm = stripPrefix(finalNeighborId);
        let node = nodeRegistry.get(finalNorm);
        if (!node) {
            node = ensureNode(finalNeighborId, isOut ? rel.target_type : rel.source_type);
            nodeRegistry.set(finalNorm, node);
        }

        // Relation Affinity Logic
        const rType = (rel.relation_type || 'RELATED').toUpperCase();
        if (!node.relation || node.relation === 'RELATED') {
            node.relation = rType;
        }

        // Tier Assignment
        if (!node._mapped) {
            node._mapped = true;
            if (node.type === 'knowledge') {
                tiers.explanation.nodes.push(node);
            } else if (node.type === 'model' || node.type === 'tool' || node.type === 'dataset' || node.type === 'unknown') {
                tiers.core.nodes.push(node); // Default unknown/unprefixed models to Core
            } else if (node.type === 'agent' || node.type === 'space' || node.type === 'paper') {
                tiers.utility.nodes.push(node);
            } else if (node.type === 'report') {
                tiers.digest.nodes.push(node);
            }
        }
    });

    // Matrix-Specific Injection (V16.3: Improved Local Density)
    if (entity) {
        const inject = (id, typeHint, relType) => {
            const norm = stripPrefix(id);
            if (norm === normRoot) return;
            
            let finalId = id;
            if (id.startsWith('knowledge--')) {
                let slug = norm.split('--').pop();
                if (SLUG_MAPPING[slug]) slug = SLUG_MAPPING[slug];
                if (!validSlugs.has(slug)) return;
                finalId = `knowledge--${slug}`;
            }

            const finalNorm = stripPrefix(finalId);
            let node = nodeRegistry.get(finalNorm);
            if (!node) {
                node = ensureNode(finalId, typeHint);
                nodeRegistry.set(finalNorm, node);
            }
            if (!node.relation || node.relation === 'RELATED') node.relation = relType;
            
            if (!node._mapped) {
                node._mapped = true;
                if (node.type === 'knowledge') tiers.explanation.nodes.push(node);
                else if (['model', 'tool', 'dataset', 'unknown'].includes(node.type)) tiers.core.nodes.push(node);
                else if (['agent', 'space', 'paper'].includes(node.type)) tiers.utility.nodes.push(node);
                else if (node.type === 'report') tiers.digest.nodes.push(node);
            }
        };

        if (Array.isArray(entity.arxiv_refs)) entity.arxiv_refs.forEach(ref => inject(`arxiv--${ref}`, 'paper', 'CITES'));
        if (Array.isArray(entity.datasets_used)) entity.datasets_used.forEach(ds => inject(`dataset--${ds.replace(/\//g, '--')}`, 'dataset', 'TRAINED_ON'));
        if (Array.isArray(entity.similar_models)) entity.similar_models.forEach(m => inject(`model--${m.replace(/\//g, '--')}`, 'model', 'RELATED'));

        if (type === 'model' && entity.base_model) {
            inject(`hf-model--${entity.base_model.replace(/\//g, '--')}`, 'model', 'BASED_ON');
        } else if (type === 'agent' && entity.framework) {
            inject(`tool--${entity.framework.toLowerCase()}`, 'tool', 'STACK');
        } else if (type === 'space') {
            const modelsUsed = entity.meta_json?.models_used || entity.models_used || [];
            modelsUsed.forEach(m => inject(`model--${m.replace(/\//g, '--')}`, 'model', 'USES'));
        }

        if (Array.isArray(entity.knowledge_links)) {
            entity.knowledge_links.forEach(l => {
                const slug = typeof l === 'string' ? l : l.slug;
                inject(`knowledge--${slug}`, 'knowledge', 'EXPLAINS');
                const norm = stripPrefix(`knowledge--${slug}`);
                const node = nodeRegistry.get(norm);
                if (node && !node.name && typeof l !== 'string' && l.title) node.name = l.title;
            });
        }
    }
} catch (e) {
    console.error('[NeuralMeshHub] V16.2 Execution Error:', e);
}

const hasRelations = Object.values(tiers).some(t => t.nodes.length > 0);
---

{hasRelations && (
<section class="neural-graph-explorer" id="neural-mesh-hub">
    <div class="header">
        <div class="title-group">
            <h3 class="title">üï∏Ô∏è Neural Mesh Hub</h3>
            <p class="subtitle">Interconnecting Research, Data & Ecosystem</p>
        </div>
    </div>
    
    <div class="mesh-container space-y-10 mt-8">
        {Object.entries(tiers).map(([key, tier]) => tier.nodes.length > 0 && (
            <div class={`mesh-tier mesh-tier-${key}`} data-zone={tier.zone}>
                <div class="tier-header flex items-center gap-3 mb-6">
                    <span class="tier-icon text-xl p-2 bg-gray-50 dark:bg-gray-900 rounded-lg border border-gray-100 dark:border-gray-800 shadow-sm">
                        {tier.icon}
                    </span>
                    <div class="flex-1">
                        <h4 class="text-xs font-black text-gray-400 dark:text-gray-500 uppercase tracking-[0.2em]">
                            {tier.title}
                        </h4>
                        <div class="h-px w-full bg-gradient-to-r from-gray-100 dark:from-gray-800 to-transparent mt-2"></div>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-5">
                    {tier.nodes.map(node => {
                        const cleanId = node.id.replace(/^(hf-model|hf-agent|hf-tool|hf-dataset|hf-space|model|agent|tool|dataset|space|kb|concept|knowledge|report|arxiv|paper|huggingface|huggingface_deepspec|github|replicate)[:\-]+/, '')
                                               .replace(/^(hf-model|hf-agent|hf-tool|hf-dataset|hf-space|huggingface_deepspec|knowledge|kb|report|arxiv|dataset|tool)--/, '');
                        const urlSlug = cleanId.replace(/--/g, '/').replace(/:/g, '/');
                        let path = node.type === 'knowledge' ? `/knowledge/${urlSlug}` : node.type === 'report' ? `/reports/${urlSlug}` : node.type === 'paper' ? `/paper/${urlSlug}` : `/${node.type}/${urlSlug}`;
                        
                        return (
                            <a href={path} class={`mesh-node group relative p-4 bg-white dark:bg-gray-800/40 border border-gray-100 dark:border-gray-700/50 rounded-2xl hover:border-indigo-500/50 hover:shadow-xl hover:shadow-indigo-500/5 transition-all duration-300`}>
                                <div class="flex items-start gap-4">
                                    <div class="node-icon-wrapper relative">
                                        <span class="text-3xl filter grayscale group-hover:grayscale-0 transition-all duration-500 block">
                                            {node.icon || 'üì¶'}
                                        </span>
                                        {node.relation && (
                                            <span class="relation-badge absolute -top-2 -right-2 px-1.5 py-0.5 bg-indigo-500 text-[8px] font-black text-white rounded shadow-sm uppercase tracking-tighter">
                                                {node.relation}
                                            </span>
                                        )}
                                    </div>
                                    <div class="flex-1 min-w-0">
                                        <div class="flex items-center justify-between gap-2 mb-1">
                                            <span class="text-sm font-bold text-gray-900 dark:text-white truncate group-hover:text-indigo-500 transition-colors">
                                                {node.name}
                                            </span>
                                            <span class="text-[8px] font-black uppercase tracking-tighter px-1.5 py-0.5 rounded bg-gray-50 dark:bg-gray-900 text-gray-400 border border-gray-100 dark:border-gray-800">
                                                {node.type}
                                            </span>
                                        </div>
                                        <p class="text-[10px] text-gray-500 dark:text-gray-400 line-clamp-1">
                                            {node.author || 'Ecosystem Node'}
                                        </p>
                                    </div>
                                    <div class="flex flex-col justify-center opacity-30 group-hover:opacity-100 transition-opacity">
                                        <span class="text-indigo-500 translate-x-0 group-hover:translate-x-1 transition-transform">‚Üí</span>
                                    </div>
                                </div>
                            </a>
                        );
                    })}
                </div>
            </div>
        ))}
    </div>
</section>
)}

<style>
    .neural-graph-explorer {
        padding: 1.5rem;
    }
    @media (max-width: 640px) {
        .neural-graph-explorer {
            padding: 1rem;
        }
    }
</style>
