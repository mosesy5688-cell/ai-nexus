---
/**
 * Neural Graph Explorer V15.2
 * Art.11-G: Version-locked static graph from relations.json
 * V15.2: Updated to parse actual relations.json structure
 */

interface Props {
    currentModelId?: string;
    entity?: any;
}

const { currentModelId, entity } = Astro.props;

// Graph data structures
let graphNodes: { id: string; name: string; author: string; type: string; fni: number }[] = [];
let graphLinks: { source: string; target: string; type: string; weight: number }[] = [];
let graphVersion = '15.13';
let relatedNodes: typeof graphNodes = [];
let totalNodes = 0;
let totalLinks = 0;

try {
    const runtime = Astro.locals.runtime;
    const nodeMap = new Map<string, typeof graphNodes[0]>();

    // 1. Local Extraction (Highest Priority for Instant Value)
    if (entity) {
        const rootId = currentModelId || entity.id || 'current';
        const parts = rootId.split('--');
        
        // Add root node
        if (!nodeMap.has(rootId)) {
            nodeMap.set(rootId, {
                id: rootId,
                name: entity.name || parts[parts.length - 1] || 'Current',
                author: entity.author || (parts.length > 1 ? parts[parts.length - 2] : ''),
                type: entity.type || 'model',
                fni: entity.fni_score || 0
            });
        }

        // Extract Knowledge Links (EXPLAIN)
        const kLinks = entity.knowledge_links || entity.relations?.knowledge || entity.meta?.extended?.relations?.knowledge || [];
        kLinks.forEach((link: any) => {
            const lid = typeof link === 'string' ? link : link.id;
            const lname = typeof link === 'string' ? link : (link.name || link.title || lid);
            if (!nodeMap.has(lid)) {
                nodeMap.set(lid, { id: lid, name: lname, author: 'Wiki', type: 'concept', fni: 0 });
            }
            graphLinks.push({ source: rootId, target: lid, type: 'EXPLAIN', weight: 1.0 });
        });

        // Extract Paper Refs (IMPLEMENTS)
        const aRefs = entity.arxiv_refs || entity.relations?.papers || entity.meta?.extended?.relations?.papers || [];
        aRefs.forEach((ref: any) => {
            const rid = typeof ref === 'string' ? `arxiv--${ref}` : (ref.id || `arxiv--${ref.arxiv_id}`);
            const rname = typeof ref === 'string' ? `Paper ${ref}` : (ref.title || ref.id);
            if (!nodeMap.has(rid)) {
                nodeMap.set(rid, { id: rid, name: rname, author: 'ArXiv', type: 'paper', fni: 0 });
            }
            graphLinks.push({ source: rootId, target: rid, type: 'IMPLEMENTS', weight: 0.9 });
        });

        // Extract Similar (ALT)
        const sModels = entity.similar_models || entity.relations?.similar || entity.meta?.extended?.relations?.similar || [];
        sModels.forEach((sim: any) => {
            const sid = typeof sim === 'string' ? sim : sim.id;
            const sname = typeof sim === 'string' ? sid.split('--').pop() : (sim.name || sid);
            if (!nodeMap.has(sid)) {
                nodeMap.set(sid, { id: sid, name: sname, author: 'Similar', type: 'model', fni: (sim.fni_score || 0) });
            }
            graphLinks.push({ source: rootId, target: sid, type: 'ALT', weight: 0.8 });
        });
    }

    // 2. Global Backup (Optional sync)
    if (runtime?.env?.R2_ASSETS) {
        const r2 = runtime.env.R2_ASSETS;
        const graphFile = await r2.get('cache/relations.json');
        if (graphFile) {
            const rawData = await graphFile.json() as any;
            const relations = rawData.relations || [];
            
            for (const rel of relations) {
                // Determine node types for source and target
                const getRelType = (rid, rtype) => {
                    if (rid.startsWith('arxiv:') || rid.startsWith('arxiv--')) return 'paper';
                    if (rid.startsWith('concept--')) return 'concept';
                    if (rid.startsWith('report--')) return 'report';
                    if (rid.startsWith('hf-space--')) return 'space';
                    if (rid.startsWith('hf-dataset--')) return 'dataset';
                    return rtype || 'model';
                };

                // Only add if not already in map (prefer local data)
                if (rel.source_id && !nodeMap.has(rel.source_id)) {
                    const parts = rel.source_id.split('--');
                    nodeMap.set(rel.source_id, {
                        id: rel.source_id,
                        name: (parts.pop() || rel.source_id).split(':').pop(),
                        author: parts.length > 1 ? parts[parts.length - 2] : '',
                        type: getRelType(rel.source_id, rel.source_type),
                        fni: 0
                    });
                }
                if (rel.target_id && !nodeMap.has(rel.target_id)) {
                    const parts = rel.target_id.split('--');
                    nodeMap.set(rel.target_id, {
                        id: rel.target_id,
                        name: (parts.pop() || rel.target_id).split(':').pop(),
                        author: parts.length > 1 ? parts[parts.length - 2] : '',
                        type: getRelType(rel.target_id, rel.target_type),
                        fni: 0
                    });
                }
                
                graphLinks.push({
                    source: rel.source_id,
                    target: rel.target_id,
                    type: rel.relation_type || 'RELATED',
                    weight: rel.confidence || 0.8
                });
            }
        }
    }

    graphNodes = Array.from(nodeMap.values());
    totalNodes = graphNodes.length;
    totalLinks = graphLinks.length;
    
    // Find related nodes for the current entity (Now including the locally extracted ones)
    if (currentModelId || (entity && entity.id)) {
        const targetId = currentModelId || entity.id;
        const normalizedId = targetId.toLowerCase()
            .replace(/^(arxiv|hf-space|hf-model|hf-dataset|github|model|agent|tool|dataset)--/, '');
        
        const relatedIds = new Set<string>();
        
        for (const link of graphLinks) {
            const srcClean = link.source.toLowerCase()
                .replace(/^(arxiv|hf-space|hf-model|hf-dataset|github|model|agent|tool|dataset)--/, '');
            const tgtClean = link.target.toLowerCase()
                .replace(/^(arxiv|hf-space|hf-model|hf-dataset|github|model|agent|tool|dataset)--/, '');
            
            const srcLastPart = srcClean.split('--').pop() || '';
            const tgtLastPart = tgtClean.split('--').pop() || '';
            const idLastPart = normalizedId.split('--').pop() || normalizedId;
            
            if (srcClean === normalizedId || srcClean.includes(normalizedId) || srcLastPart === idLastPart) {
                if (link.target !== targetId) relatedIds.add(link.target);
            } else if (tgtClean === normalizedId || tgtClean.includes(normalizedId) || tgtLastPart === idLastPart) {
                if (link.source !== targetId) relatedIds.add(link.source);
            }
        }
        
        relatedNodes = graphNodes
            .filter(n => relatedIds.has(n.id))
            .slice(0, 12); // Increased for better view
    }
} catch (e) {
    console.error('[NeuralGraphExplorer] Error:', e);
}

const hasGraph = totalNodes > 0;
const hasRelatedNodes = relatedNodes.length > 0;
---


<section class="neural-graph-explorer" id="neural-graph-explorer">
    <div class="header">
        <div class="title-group">
            <h3 class="title">
                üï∏Ô∏è Neural Hub Explorer
            </h3>
            <p class="subtitle">Interconnecting Models, Knowledge & Reports</p>
        </div>
        <div class="view-controls">
            <button class="view-btn active" data-view="grid">Perspective</button>
            <button class="view-btn" data-view="graph" id="activate-graph">Interactive Map</button>
            {graphVersion && (
                <span class="version-badge">v{graphVersion}</span>
            )}
        </div>
    </div>
    
    <div class="content-wrapper">
        <!-- View 1: Static Grid (SEO & Instant Load) -->
        <div class="view-pane active" id="pane-grid">
            {hasRelatedNodes ? (
                <div class="related-grid">
                    {relatedNodes.map(node => {
                        const slugParts = node.id.split('--');
                        const cleanParts = slugParts.length > 2 ? slugParts.slice(1) : slugParts;
                        const urlSlug = cleanParts.join('/');
                        
                        // Path mapping based on type
                        let path = `/${node.type}/${urlSlug}`;
                        if (node.type === 'concept') path = `/knowledge/${urlSlug}`;
                        if (node.type === 'report') path = `/reports/${urlSlug}`;
                        
                        return (
                        <a href={path} class={`related-card type-${node.type}`}>
                            <div class="card-header">
                                <span class="model-name">{node.name}</span>
                                <span class={`type-badge color-${node.type}`}>{node.type}</span>
                            </div>
                            <div class="card-meta">
                                <span class="author">{node.author}</span>
                            </div>
                            {node.fni > 0 && (
                                <div class="fni-score">
                                    FNI: <span class={`score ${node.fni >= 70 ? 'high' : node.fni >= 50 ? 'mid' : 'low'}`}>
                                        {node.fni.toFixed(1)}
                                    </span>
                                </div>
                            )}
                        </a>
                    )})}
                </div>
            ) : (
                <div class="graph-stats">
                    <div class="stats-row">
                        <div class="stat">
                            <span class="stat-value">{totalNodes}</span>
                            <span class="stat-label">Entities</span>
                        </div>
                        <div class="stat">
                            <span class="stat-value">{totalLinks}</span>
                            <span class="stat-label">Connections</span>
                        </div>
                    </div>
                    <a href="/ranking" class="explore-link">Explore Rankings ‚Üí</a>
                </div>
            )}
        </div>

        <!-- View 2: Interactive D3 Graph (On Demand) -->
        <div class="view-pane" id="pane-graph">
            <div id="d3-container" 
                 data-id={currentModelId || entity?.id} 
                 data-type={entity?.type || 'model'}
                 class="d3-canvas">
                <div class="graph-loading">
                    <div class="spinner"></div>
                    <span>Initializing Neural Hub...</span>
                </div>
                <svg id="visual-graph"></svg>
            </div>
            <div class="graph-legend">
                <span class="legend-item"><i class="dot model"></i> Model</span>
                <span class="legend-item"><i class="dot paper"></i> Paper</span>
                <span class="legend-item"><i class="dot concept"></i> Knowledge</span>
                <span class="legend-item"><i class="dot report"></i> Report</span>
            </div>
        </div>
    </div>
</section>

<!-- Defer D3 integration to visible idle -->
<script defer src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>

<script is:inline>
(function() {
    const explorer = document.getElementById('neural-graph-explorer');
    const activateBtn = document.getElementById('activate-graph');
    const panes = { grid: document.getElementById('pane-grid'), graph: document.getElementById('pane-graph') };
    const buttons = explorer.querySelectorAll('.view-btn');
    
    let graphInitialized = false;
    // Default to Grid on Mobile even if previously set to Graph
    if (isMobile) {
        panes.grid.classList.add('active');
        panes.graph.classList.remove('active');
        buttons.forEach(b => {
            if (b.dataset.view === 'grid') b.classList.add('active');
            else b.classList.remove('active');
        });
    }

    buttons.forEach(btn => {
        btn.addEventListener('click', () => {
            const view = btn.dataset.view;
            buttons.forEach(b => b.classList.toggle('active', b === btn));
            panes.grid.classList.toggle('active', view === 'grid');
            panes.graph.classList.toggle('active', view === 'graph');
            
            if (view === 'graph' && !graphInitialized) {
                initD3Graph();
                graphInitialized = true;
            }
        });
    });

    function initD3Graph() {
        const container = document.getElementById('d3-container');
        const entityId = container.dataset.id;
        const entityType = container.dataset.type;
        const svg = d3.select("#visual-graph");
        const loading = container.querySelector('.graph-loading');
        
        const width = container.clientWidth;
        const height = 400;
        
        // V15.5 Pure Static Data Fetch: Load global relations and filter locally
        const CDN_BASE = 'https://cdn.free2aitools.com';
        
        Promise.all([
            fetch(`${CDN_BASE}/cache/relations.json`).then(r => r.json()),
            // Fetch entities list or specific entity cache if needed
        ]).then(([relsData]) => {
            const relations = relsData.relations || [];
            
            // Filter locally for the current entity's hub
            const relevantNodes = new Map();
            const relevantLinks = [];
            
            // Add self
            relevantNodes.set(entityId, { id: entityId, name: entityId.split('--').pop(), group: entityType });

            relations.forEach(rel => {
                if (rel.source_id === entityId || rel.target_id === entityId) {
                    const otherId = rel.source_id === entityId ? rel.target_id : rel.source_id;
                    const otherType = rel.source_id === entityId ? (rel.target_type || 'model') : (rel.source_type || 'model');
                    
                    if (!relevantNodes.has(otherId)) {
                        relevantNodes.set(otherId, { 
                            id: otherId, 
                            name: otherId.split('--').pop().split(':').pop(), 
                            group: otherType 
                        });
                    }
                    relevantLinks.push({
                        source: rel.source_id,
                        target: rel.target_id,
                        type: rel.relation_type,
                        weight: rel.confidence || 0.8
                    });
                }
            });

            loading.style.display = 'none';
            render({ nodes: Array.from(relevantNodes.values()), links: relevantLinks });
        }).catch(err => {
            console.error('[StaticGraph] Error:', err);
            loading.innerHTML = '<span class="text-red-400">Hub data offline. Check CDN.</span>';
        });

        function render(data) {
            svg.selectAll("*").remove();
            const g = svg.append("g");
            
            const simulation = d3.forceSimulation(data.nodes)
                .force("link", d3.forceLink(data.links).id(d => d.id).distance(100))
                .force("charge", d3.forceManyBody().strength(-200))
                .force("center", d3.forceCenter(width / 2, height / 2));

            const link = g.append("g")
                .attr("stroke", "rgba(99, 102, 241, 0.2)")
                .selectAll("line")
                .data(data.links)
                .join("line");

            const node = g.append("g")
                .selectAll("circle")
                .data(data.nodes)
                .join("circle")
                .attr("r", d => d.id === entityId ? 10 : 6)
                .attr("fill", d => getNodeColor(d.group))
                .attr("cursor", "pointer")
                .call(d3.drag()
                    .on("start", (e, d) => {
                        if (!e.active) simulation.alphaTarget(0.3).restart();
                        d.fx = d.x; d.fy = d.y;
                    })
                    .on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; })
                    .on("end", (e, d) => {
                        if (!e.active) simulation.alphaTarget(0);
                        d.fx = null; d.fy = null;
                    })
                );

            node.on("click", (e, d) => {
                // V15.5: Robust link generation
                const id = d.id;
                const group = d.group;
                
                let path = '';
                if (group === 'concept') {
                    // kb--what-is-mmlu -> /knowledge/what-is-mmlu
                    const slug = id.replace(/^(kb|concept)--/, '');
                    path = `/knowledge/${slug}`;
                } else if (group === 'report') {
                    // report--2026-01-04 -> /reports/2026-01-04
                    const slug = id.replace(/^report--/, '');
                    path = `/reports/${slug}`;
                } else if (group === 'model' || group === 'agent' || group === 'tool' || group === 'dataset' || group === 'space') {
                    // hf-model--author--name -> /model/author/name
                    const cleanId = id.replace(/^(hf-model|hf-agent|hf-tool|hf-dataset|hf-space|model|agent|tool|dataset|space)--/, '');
                    const slug = cleanId.replace(/--/g, '/');
                    path = `/${group}/${slug}`;
                } else if (group === 'paper') {
                    // arxiv--2312.12345 -> /paper/2312.12345
                    const slug = id.replace(/^(arxiv|paper)--/, '');
                    path = `/paper/${slug}`;
                } else {
                    // Final fallback
                    path = `/${group}/${id.split('--').pop()}`;
                }
                
                window.location.href = path;
            });

            simulation.on("tick", () => {
                link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                node.attr("cx", d => d.x).attr("cy", d => d.y);
            });
        }

        function getNodeColor(group) {
            const colors = {
                model: '#818cf8',
                paper: '#c084fc',
                dataset: '#4ade80',
                concept: '#6366f1',
                report: '#fbbf24',
                agent: '#f87171',
                tool: '#fb923c'
            };
            return colors[group] || '#94a3b8';
        }
    }
})();
</script>

<style>
    .neural-graph-explorer {
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(15, 23, 42, 0.98));
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 16px;
        padding: 1.75rem;
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.3);
    }
    
    .header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        margin-bottom: 1.5rem;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        padding-bottom: 1rem;
    }

    .title {
        color: #f8fafc;
        font-size: 1.25rem;
        font-weight: 800;
        margin: 0;
        letter-spacing: -0.025em;
    }
    
    .subtitle {
        color: #64748b;
        font-size: 0.75rem;
        margin: 0.25rem 0 0;
        text-transform: uppercase;
        font-weight: 700;
        letter-spacing: 0.05em;
    }

    .view-controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    .view-btn {
        background: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #94a3b8;
        padding: 0.4rem 0.8rem;
        border-radius: 8px;
        font-size: 0.75rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
    }

    .view-btn.active {
        background: #6366f1;
        color: white;
        border-color: #818cf8;
        box-shadow: 0 0 15px rgba(99, 102, 241, 0.4);
    }

    .view-pane {
        display: none;
    }

    .view-pane.active {
        display: block;
        animation: fadeIn 0.3s ease-out;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .related-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
        gap: 1rem;
    }
    
    .related-card {
        background: rgba(30, 41, 59, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 1rem;
        text-decoration: none;
        transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
    }

    .related-card:hover {
        background: rgba(30, 41, 59, 0.8);
        border-color: rgba(99, 102, 241, 0.4);
        transform: translateY(-4px);
    }

    .type-badge {
        font-size: 0.6rem;
        padding: 0.125rem 0.5rem;
        border-radius: 9999px;
        text-transform: uppercase;
        font-weight: 800;
    }

    .color-model { background: rgba(129, 140, 248, 0.1); color: #818cf8; }
    .color-paper { background: rgba(192, 132, 252, 0.1); color: #c084fc; }
    .color-concept { background: rgba(99, 102, 241, 0.1); color: #818cf8; }
    .color-report { background: rgba(251, 191, 36, 0.1); color: #fbbf24; }

    .d3-canvas {
        width: 100%;
        height: 400px;
        background: rgba(15, 23, 42, 0.3);
        border-radius: 12px;
        position: relative;
        overflow: hidden;
    }

    #visual-graph {
        width: 100%;
        height: 100%;
    }

    .graph-loading {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 1rem;
        z-index: 10;
        background: rgba(15, 23, 42, 0.8);
    }

    .spinner {
        width: 30px;
        height: 30px;
        border: 3px solid rgba(99, 102, 241, 0.3);
        border-top-color: #6366f1;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .graph-legend {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
        padding: 0.75rem;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 8px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.7rem;
        color: #94a3b8;
        font-weight: 600;
    }

    .dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
    }

    .dot.model { background: #818cf8; }
    .dot.paper { background: #c084fc; }
    .dot.concept { background: #6366f1; }
    .dot.report { background: #fbbf24; }

    .stat-value { color: #818cf8; font-size: 1.75rem; font-weight: 800; }
    .stat-label { color: #64748b; font-size: 0.7rem; text-transform: uppercase; font-weight: 700; }
</style>
