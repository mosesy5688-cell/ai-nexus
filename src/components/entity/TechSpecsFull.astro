---
/**
 * TechSpecsFull - V15.0 Unified Technical Specification Section
 * Aggregates SpecCards into logical groups (Hardware, Training, Metadata)
 */
import SpecCard from './SpecCard.astro';

interface Props {
  entity: any;
  type: string;
}

const { entity = {}, type } = Astro.props;

// 1. Hardware & Scale Mapping
const hardwareSpecs = [];
if (type === 'model') {
  // Enhanced mapping for Parameter Count (Hydrator Promoted)
  const pCount = entity?.params_billions || entity?.parameters_billions || entity?.parameters || entity?.num_parameters;
  hardwareSpecs.push({ 
    label: 'Parameters', 
    value: pCount ? (typeof pCount === 'number' && pCount > 1000 ? `${(pCount/1e9).toFixed(1)}B` : `${pCount}${typeof pCount === 'number' ? 'B' : ''}`) : '-', 
    highlight: true 
  });
  
  // Robust Architecture lookup (Hydrator Promoted + Fallback)
  const arch = entity?.architecture || entity?.model_type || entity?.config?.model_type;
  hardwareSpecs.push({ label: 'Architecture', value: arch || '-' });
  
  // Context Length (Hydrator Promoted + Config Fallback)
  const ctx = entity?.context_length || 
              entity?.config?.max_position_embeddings || 
              entity?.config?.n_ctx;

  // V16.5: Quantization Recovery (Ghost Field)
  if (entity?.quant_bits) {
    hardwareSpecs.push({ label: 'Quantization', value: `${entity.quant_bits}-bit`, highlight: true });
  }

  hardwareSpecs.push({ 
    label: 'Context Length', 
    value: ctx ? (ctx >= 1024 ? `${(ctx / 1024).toFixed(0)}K` : ctx) : '-' 
  });

  // V16.96: Model Size / VRAM Requirement
  if (entity?.size_kb) {
    const size = entity.size_kb;
    hardwareSpecs.push({ label: 'Model Size', value: size > 1048576 ? `${(size/1048576).toFixed(1)}GB` : `${(size/1024).toFixed(0)}MB` });
  }
} else if (type === 'dataset') {
  hardwareSpecs.push({ label: 'Size', value: entity?.size_bytes ? `${(entity.size_bytes / 1e9).toFixed(2)} GB` : (entity?.size_gb ? `${entity.size_gb} GB` : (entity?.meta?.extended?.size || '-')), highlight: true });
  hardwareSpecs.push({ label: 'Total Rows', value: entity?.rows ? (Number(entity.rows) >= 1e6 ? (Number(entity.rows) / 1e6).toFixed(1) + 'M' : Number(entity.rows).toLocaleString()) : (entity?.meta?.extended?.rows || '-') });
  hardwareSpecs.push({ label: 'Files', value: entity?.files_count || entity?.meta?.extended?.files || '-' });
  
  if (entity?.features) {
     hardwareSpecs.push({ label: 'Features', value: Array.isArray(entity.features) ? entity.features.length : (entity.features && typeof entity.features === 'object' ? Object.keys(entity.features).length : 'Aggregated') });
  }
  // V19: Popularity metrics
  if (entity?.downloads) hardwareSpecs.push({ label: 'Downloads', value: Number(entity.downloads) >= 1e6 ? `${(Number(entity.downloads)/1e6).toFixed(1)}M` : Number(entity.downloads).toLocaleString() });
  if (entity?.likes) hardwareSpecs.push({ label: 'Likes', value: Number(entity.likes).toLocaleString() });
} else if (type === 'paper') {
  hardwareSpecs.push({ label: 'Citations', value: entity?.citations || entity?.citation_count || entity?.meta?.extended?.citations || '-', highlight: true });
  hardwareSpecs.push({ label: 'Year', value: entity?.published_date ? new Date(entity.published_date).getFullYear() : (entity?.year || entity?.meta?.extended?.year || '-') });
  hardwareSpecs.push({ label: 'Page Count', value: entity?.pages || entity?.meta?.extended?.pages || '-' });
  // V19: Author count
  const authorList = entity?.authors;
  if (Array.isArray(authorList) && authorList.length > 0) {
    hardwareSpecs.push({ label: 'Authors', value: authorList.length });
  }
  // V19: ArXiv category
  if (entity?.arxiv_category || entity?.primary_category) {
    hardwareSpecs.push({ label: 'Category', value: entity.arxiv_category || entity.primary_category });
  }
} else if (type === 'agent' || type === 'tool') {
  hardwareSpecs.push({ label: 'GitHub Stars', value: (entity?.github_stars || entity?.stars || entity?.meta?.extended?.stars)?.toLocaleString() || '-', highlight: true });
  hardwareSpecs.push({ label: 'Language', value: entity?.language || entity?.meta?.extended?.language || 'Python' });
  hardwareSpecs.push({ label: 'Version', value: entity?.version || entity?.meta?.extended?.version || 'v1.0.0' });
  
  // V16.96: Repo Size (Promoted from meta.storage_bytes)
  const repoSize = entity?.size_kb || entity?.meta_json?.size_kb;
  if (repoSize) {
     hardwareSpecs.push({ label: 'Repo Size', value: repoSize > 1024 ? `${(repoSize/1024).toFixed(1)}MB` : `${repoSize}KB` });
  }
  // V19: Popularity metrics
  if (entity?.downloads) hardwareSpecs.push({ label: 'Downloads', value: Number(entity.downloads) >= 1e6 ? `${(Number(entity.downloads)/1e6).toFixed(1)}M` : Number(entity.downloads).toLocaleString() });
  if (entity?.likes) hardwareSpecs.push({ label: 'Likes', value: Number(entity.likes).toLocaleString() });
} else if (type === 'space') {
  hardwareSpecs.push({ label: 'SDK', value: entity?.sdk || entity?.meta?.extended?.sdk || '-', highlight: true });
  hardwareSpecs.push({ label: 'Hardware', value: entity?.hardware || entity?.meta?.extended?.hardware || 'V100' });
  hardwareSpecs.push({ label: 'Status', value: entity?.runtime?.stage || 'Running' });
  // V19: Popularity metrics
  if (entity?.likes) hardwareSpecs.push({ label: 'Likes', value: Number(entity.likes).toLocaleString() });
}

// 2. Training & Environment
const trainingSpecs = [];
if (type === 'model') {
  trainingSpecs.push({ label: 'Library', value: entity?.library_name || entity?.config?.library_name || '-' });
  trainingSpecs.push({ label: 'Precision', value: entity?.precision || entity?.config?.torch_dtype || 'float16' });
  trainingSpecs.push({ label: 'Tokenizer', value: entity?.config?.tokenizer_class || entity?.config?.model_type || '-' });
}
 else if (type === 'dataset') {
  trainingSpecs.push({ label: 'Format', value: entity?.format || 'Parquet' });
  trainingSpecs.push({ label: 'Cleaning', value: entity?.cleaned ? 'Pre-cleaned' : 'Raw' });
} else if (type === 'agent' || type === 'tool') {
  trainingSpecs.push({ label: 'License', value: entity?.license });
  trainingSpecs.push({ label: 'Forks', value: entity?.github_forks || entity?.forks });
  // V19: Framework if available
  if (entity?.framework) trainingSpecs.push({ label: 'Framework', value: entity.framework });
}

// 3. Model Configuration (V15.9 Enhanced)
const configSpecs = [];
if (type === 'model') {
  if (entity?.num_layers) configSpecs.push({ label: 'Layers', value: entity.num_layers });
  if (entity?.hidden_size) configSpecs.push({ label: 'Dimension', value: entity.hidden_size.toLocaleString() });
  if (entity?.num_heads) configSpecs.push({ label: 'Atn Heads', value: entity.num_heads });
  if (entity?.kv_heads) configSpecs.push({ label: 'KV Heads', value: entity.kv_heads });
  if (entity?.moe_experts) configSpecs.push({ label: 'Total Experts', value: entity.moe_experts });
  if (entity?.moe_active) configSpecs.push({ label: 'Active Experts', value: entity.moe_active });
  if (entity?.vocab_size) configSpecs.push({ label: 'Vocab', value: `${(entity.vocab_size / 1000).toFixed(0)}K` });
}

// 4. Academic & Lineage (V16.5 Structural Integration)
const lineageSpecs = [];
if (entity?.base_model) {
  lineageSpecs.push({ 
    label: 'Ancestry', 
    value: String(entity.base_model).split('/').pop(), 
    href: `/model/${String(entity.base_model).replace(/\//g, '--')}` 
  });
}
if (entity?.arxiv_id || entity?.arxiv_ref) {
  lineageSpecs.push({ 
    label: 'Research', 
    value: `arXiv:${entity.arxiv_ref || entity.arxiv_id}`, 
    href: `https://arxiv.org/abs/${entity.arxiv_ref || entity.arxiv_id}` 
  });
}

// 5. Cloud & Access Rights
const cloudSpecs = [
  { label: 'Source', value: entity?.source || 'HuggingFace' },
  { label: 'License', value: entity?.license_spdx || entity?.license || 'Open Access' },
].filter(s => s.value);

---

<section class="space-y-10 group">
  <div class="flex items-center gap-5">
    <div class="flex items-center gap-3">
       <div class="p-2.5 bg-indigo-600/10 dark:bg-indigo-400/10 rounded-xl">
          <span class="text-xl">ðŸ“Š</span>
       </div>
       <h2 class="text-2xl font-black text-gray-900 dark:text-white tracking-tight">
         Engineering Specs
       </h2>
    </div>
    <div class="h-[1px] flex-grow bg-gradient-to-r from-indigo-100 via-indigo-50 to-transparent dark:from-indigo-900/50 dark:via-indigo-900/10 dark:to-transparent"></div>
    <span class="text-[9px] font-black uppercase tracking-[0.2em] text-gray-400 dark:text-gray-500 hidden sm:block">V16.2 Platform Optimized</span>
  </div>

  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 px-1">
    {hardwareSpecs.length > 0 && (
      <SpecCard title="Hardware" icon="âš¡" specs={hardwareSpecs} accentColor="indigo" />
    )}
    
    {trainingSpecs.length > 0 && (
      <SpecCard title="Lifecycle" icon="ðŸ§ " specs={trainingSpecs} accentColor="emerald" />
    )}

    {configSpecs.length > 0 && (
      <SpecCard title="Structure" icon="âš™ï¸" specs={configSpecs} accentColor="amber" />
    )}
    
    {lineageSpecs.length > 0 && (
      <SpecCard title="Lineage" icon="ðŸ§¬" specs={lineageSpecs} accentColor="purple" />
    )}

    {cloudSpecs.length > 0 && (
      <SpecCard title="Identity" icon="ðŸŒ" specs={cloudSpecs} accentColor="rose" />
    )}
  </div>
</section>

<script>
  function initTechSpecsSync() {
    window.addEventListener('neural-mining-complete', (e: any) => {
      const mined = e.detail;
      if (!mined) return;

      console.log('[TechSpecs] Synchronizing with mined data:', mined);
      
      const cards = document.querySelectorAll('.tech-specs-full, .grid-cols-1.md\\:grid-cols-2.lg\\:grid-cols-4');
      
      cards.forEach(container => {
        // Find labels and update values
        const items = container.querySelectorAll('.flex.items-start.gap-2, div > div.text-xs');
        items.forEach(item => {
          const labelEl = item.querySelector('.text-xs, .text-gray-500');
          const valueEl = item.querySelector('.font-medium, .text-gray-900');
          
          if (labelEl && valueEl) {
            const label = labelEl.textContent?.trim();
            const currentValue = valueEl.textContent?.trim();
            
            if (currentValue === '-' || currentValue === 'Unknown') {
              if (label === 'Architecture' && mined.architecture) {
                valueEl.textContent = mined.architecture;
                valueEl.classList.add('text-green-500', 'animate-pulse');
              } else if (label === 'Parameters' && mined.params_billions) {
                valueEl.textContent = `${mined.params_billions}B`;
                valueEl.classList.add('text-green-500', 'animate-pulse');
              } else if (label === 'Context Length' && mined.context_length) {
                const ctx = mined.context_length;
                valueEl.textContent = ctx >= 1024 ? `${(ctx / 1024).toFixed(0)}K` : ctx.toString();
                valueEl.classList.add('text-green-500', 'animate-pulse');
              }
            }
          }
        });
      });
    });
  }

  initTechSpecsSync();
  document.addEventListener('astro:after-swap', initTechSpecsSync);
</script>
