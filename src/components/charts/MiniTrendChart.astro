---
/**
 * MiniTrendChart Component
 * V14.5 Phase 5: Inline mini trend chart for FNI history
 * 
 * Usage: <MiniTrendChart entityId="model-id" />
 * 
 * Features:
 * - 7-day FNI trend sparkline (canvas)
 * - Change percentage badge (up/down/stable)
 * - Lazy loads trend data from CDN
 * - Zero dependencies (no Chart.js)
 */

interface Props {
    entityId: string;
    showBadge?: boolean;
    width?: number;
    height?: number;
}

const { 
    entityId, 
    showBadge = true,
    width = 80,
    height = 28
} = Astro.props;
---

<div class="mini-trend" data-entity-id={entityId} data-w={width} data-h={height}>
    <canvas 
        class="mini-trend-canvas" 
        width={width} 
        height={height}
        aria-label="7-day FNI trend"
    ></canvas>
    {showBadge && (
        <span class="mini-trend-badge" aria-live="polite">--</span>
    )}
</div>

<style>
.mini-trend {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    min-width: fit-content;
}

.mini-trend-canvas {
    opacity: 0.3;
    transition: opacity 0.3s ease;
}

.mini-trend-canvas.loaded {
    opacity: 1;
}

.mini-trend-badge {
    font-size: 11px;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 4px;
    white-space: nowrap;
    background: var(--color-surface-2, #f0f0f0);
    color: var(--color-text-muted, #666);
}

.mini-trend-badge.up {
    background: #dcfce7;
    color: #16a34a;
}

.mini-trend-badge.down {
    background: #fee2e2;
    color: #dc2626;
}

.mini-trend-badge.stable {
    background: #e5e7eb;
    color: #6b7280;
}
</style>

<script>
// Singleton cache for trend data
let _trendCache: Record<string, any> | null = null;
let _loadPromise: Promise<Record<string, any>> | null = null;

async function loadTrendData(): Promise<Record<string, any>> {
    if (_trendCache) return _trendCache;
    if (_loadPromise) return _loadPromise;
    
    _loadPromise = fetch('/cache/trend-data.json')
        .then(res => res.ok ? res.json() : {})
        .then(data => { _trendCache = data; return data; })
        .catch(() => ({}));
    
    return _loadPromise;
}

function drawSparkline(
    canvas: HTMLCanvasElement, 
    scores: number[],
    direction: 'up' | 'down' | 'stable'
) {
    const ctx = canvas.getContext('2d');
    if (!ctx || scores.length < 2) return;
    
    const w = canvas.width, h = canvas.height;
    const pad = 3;
    const max = Math.max(...scores), min = Math.min(...scores);
    const range = max - min || 1;
    
    ctx.clearRect(0, 0, w, h);
    ctx.beginPath();
    ctx.strokeStyle = direction === 'up' ? '#22c55e' : 
                      direction === 'down' ? '#ef4444' : '#9ca3af';
    ctx.lineWidth = 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    scores.forEach((s, i) => {
        const x = pad + (i / (scores.length - 1)) * (w - pad * 2);
        const y = h - pad - ((s - min) / range) * (h - pad * 2);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    canvas.classList.add('loaded');
}

function updateBadge(el: HTMLElement, change: number, dir: string) {
    const arrow = dir === 'up' ? '↑' : dir === 'down' ? '↓' : '→';
    el.textContent = `${arrow}${Math.abs(change).toFixed(1)}%`;
    el.className = `mini-trend-badge ${dir}`;
}

async function initMiniTrends() {
    const charts = document.querySelectorAll('.mini-trend:not(.inited)');
    if (!charts.length) return;
    
    const data = await loadTrendData();
    
    charts.forEach(el => {
        let id = (el as HTMLElement).dataset.entityId;
        if (!id) return;
        
        let targetId = id;
        
        // Normalize: handle various ID formats (V16.31: Robust Matching)
        if (!data[targetId]) {
            // 1. Strip common prefixes
            const cleanId = id.replace(/^(huggingface|hf|replicate|github|arxiv|civitai|ollama)[:|-]+/, '')
                              .replace(/^(model|agent|dataset|paper|space|tool)[:|-]+/, '');
            
            // 2. Generate candidates
            const candidates = [
                id.replace(/\//g, '--').replace(/:/g, '--'), // Standard R2 swap
                `hf-model--${cleanId.replace(/\//g, '--')}`, // Common HuggingFace prefix
                `hf-dataset--${cleanId.replace(/\//g, '--')}`,
                `hf-space--${cleanId.replace(/\//g, '--')}`,
                `arxiv--${cleanId}`,
                `github--${cleanId.replace(/\//g, '--')}`,
                `replicate:${cleanId.replace(/--/g, '/')}`,
                cleanId, // Bare name
                cleanId.replace(/\//g, '--'),
                cleanId.replace(/--/g, '/')
            ];
            
            for (const cand of candidates) {
                if (data[cand]) {
                    targetId = cand;
                    break;
                }
            }
        }

        if (!data[targetId]) {
            console.warn('[MiniTrend] No data for:', id);
            return;
        }
        
        const d = data[targetId];
        const canvas = el.querySelector('canvas');
        const badge = el.querySelector('.mini-trend-badge') as HTMLElement;
        
        if (canvas && d.scores?.length >= 2) {
            drawSparkline(canvas as HTMLCanvasElement, d.scores, d.direction);
        }
        if (badge) {
            updateBadge(badge, d.change7d || 0, d.direction || 'stable');
        }
        el.classList.add('inited');
    });
}

// Init
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMiniTrends);
} else {
    initMiniTrends();
}
document.addEventListener('astro:page-load', initMiniTrends);
</script>
