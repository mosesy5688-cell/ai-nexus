---
/**
 * MiniTrendChart Component
 * V14.5 Phase 5: Inline mini trend chart for FNI history
 * 
 * Usage: <MiniTrendChart entityId="model-id" />
 * 
 * Features:
 * - 7-day FNI trend sparkline (canvas)
 * - Change percentage badge (up/down/stable)
 * - Lazy loads trend data from CDN
 * - Zero dependencies (no Chart.js)
 */

interface Props {
    entityId: string;
    showBadge?: boolean;
    width?: number;
    height?: number;
}

const { 
    entityId, 
    showBadge = true,
    width = 80,
    height = 28
} = Astro.props;
---

<div class="mini-trend-container" data-entity-id={entityId}>
    <div class="mini-trend" data-w={width} data-h={height}>
        <canvas 
            class="mini-trend-canvas" 
            aria-label="7-day FNI trend"
        ></canvas>
        {showBadge && (
            <span class="mini-trend-badge" aria-live="polite">--</span>
        )}
    </div>
</div>

<style>
.mini-trend-container {
    width: 100%;
    overflow: hidden; /* V16.35: Prevent "out of box" overflow */
    display: flex;
    justify-content: center;
}

.mini-trend {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    width: 100%;
    max-width: 100%;
}

.mini-trend-canvas {
    opacity: 0.1;
    transition: opacity 0.5s ease;
    width: 100%; /* V16.35: Responsive width */
    height: auto;
}

.mini-trend-canvas.loaded {
    opacity: 1;
}

.mini-trend-badge {
    font-size: 11px;
    font-weight: 700;
    padding: 2px 8px;
    border-radius: 6px;
    white-space: nowrap;
    background: var(--color-surface-2, #f3f4f6);
    color: var(--color-text-muted, #6b7280);
    border: 1px solid rgba(0,0,0,0.05);
}

.mini-trend-badge.up {
    background: #f0fdf4;
    color: #15803d;
}

.mini-trend-badge.down {
    background: #fef2f2;
    color: #b91c1c;
}

.mini-trend-badge.stable {
    background: #f9fafb;
    color: #4b5563;
}
.hidden { display: none !important; }
</style>

<script>
import { R2_CACHE_URL } from '../../config/constants.ts';
import { normalizeTrendId, findTrendMatch, drawSparkline, updateBadge } from '../../utils/trend-helpers.js';

// Singleton cache for trend data
let _trendCache: Record<string, any> | null = null;
let _loadPromise: Promise<Record<string, any>> | null = null;

async function loadTrendData(): Promise<Record<string, any>> {
    if (_trendCache) return _trendCache;
    if (_loadPromise) return _loadPromise;
    
    _loadPromise = fetch(`${R2_CACHE_URL}/cache/trend-data.json.gz`)
        .then(async (res) => {
            if (!res.ok) {
                const fallback = await fetch(`${R2_CACHE_URL}/cache/trend-data.json`);
                return fallback.ok ? fallback : null;
            }
            return res;
        })
        .then(async (res) => {
            if (!res) return {};
            const url = res.url;
            if (url.endsWith('.gz')) {
                const ds = new DecompressionStream('gzip');
                const stream = res.body.pipeThrough(ds);
                return await new Response(stream).json();
            }
            return await res.json();
        })
        .then(data => { _trendCache = data; return data; })
        .catch(() => ({}));
    
    return _loadPromise;
}

async function initMiniTrends() {
    const containers = document.querySelectorAll('.mini-trend-container:not(.inited)');
    if (!containers.length) return;
    
    const data = await loadTrendData();
    const dataKeys = Object.keys(data);
    const dataKeysLower = dataKeys.map(k => k.toLowerCase());
    
    containers.forEach(container => {
        const id = (container as HTMLElement).dataset.entityId;
        if (!id) return;
        
        const targetId = findTrendMatch(id, data, dataKeys, dataKeysLower);
        const fallback = container.parentElement?.querySelector('#trend-fallback');
        const entityTrend = targetId ? data[targetId] : null;
        
        if (!entityTrend || !Array.isArray(entityTrend.scores) || entityTrend.scores.length === 0) {
            console.log(`[MiniTrend] No trend record for ${id} (final target: ${targetId})`);
            if (fallback) {
                fallback.innerHTML = `<span class="opacity-60 italic">Trend data indexing pending for this node...</span>`;
                fallback.classList.remove('hidden');
            }
            return;
        }
        
        const d = entityTrend;
        const canvas = container.querySelector('canvas');
        const badge = container.querySelector('.mini-trend-badge') as HTMLElement;
        
        if (canvas) {
            const scores = d.scores || (d.latest ? [d.latest, d.latest] : []);
            if (scores.length >= 2) {
                drawSparkline(canvas as HTMLCanvasElement, scores, d.direction || 'stable');
                if (fallback) fallback.classList.add('hidden');
            }
        }
        if (badge) {
            updateBadge(badge, d.change7d || 0, d.direction || 'stable');
        }
        container.classList.add('inited');
    });
}

// Global Inits
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMiniTrends);
} else {
    initMiniTrends();
}
document.addEventListener('astro:page-load', initMiniTrends);
</script>
