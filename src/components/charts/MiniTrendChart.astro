---
/**
 * MiniTrendChart Component
 * V14.5 Phase 5: Inline mini trend chart for FNI history
 * 
 * Usage: <MiniTrendChart entityId="model-id" />
 * 
 * Features:
 * - 7-day FNI trend sparkline (canvas)
 * - Change percentage badge (up/down/stable)
 * - Lazy loads trend data from CDN
 * - Zero dependencies (no Chart.js)
 */

interface Props {
    entityId: string;
    showBadge?: boolean;
    width?: number;
    height?: number;
}

const { 
    entityId, 
    showBadge = true,
    width = 80,
    height = 28
} = Astro.props;
---

<div class="mini-trend" data-entity-id={entityId} data-w={width} data-h={height}>
    <canvas 
        class="mini-trend-canvas" 
        width={width} 
        height={height}
        aria-label="7-day FNI trend"
    ></canvas>
    {showBadge && (
        <span class="mini-trend-badge" aria-live="polite">--</span>
    )}
</div>

<style>
.mini-trend {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    min-width: fit-content;
}

.mini-trend-canvas {
    opacity: 0.3;
    transition: opacity 0.3s ease;
}

.mini-trend-canvas.loaded {
    opacity: 1;
}

.mini-trend-badge {
    font-size: 11px;
    font-weight: 600;
    padding: 2px 6px;
    border-radius: 4px;
    white-space: nowrap;
    background: var(--color-surface-2, #f0f0f0);
    color: var(--color-text-muted, #666);
}

.mini-trend-badge.up {
    background: #dcfce7;
    color: #16a34a;
}

.mini-trend-badge.down {
    background: #fee2e2;
    color: #dc2626;
}

.mini-trend-badge.stable {
    background: #e5e7eb;
    color: #6b7280;
}
</style>

<script>
import { R2_CACHE_URL } from '../../config/constants.ts';

// Singleton cache for trend data
let _trendCache: Record<string, any> | null = null;
let _loadPromise: Promise<Record<string, any>> | null = null;

async function loadTrendData(): Promise<Record<string, any>> {
    if (_trendCache) return _trendCache;
    if (_loadPromise) return _loadPromise;
    
    // V16.33: Primary CDN Fetch (Zero-Runtime)
    _loadPromise = fetch(`${R2_CACHE_URL}/cache/trend-data.json`)
        .then(async (res) => {
            if (!res.ok) {
                console.warn('[MiniTrend] CDN primary fetch failed, trying fallback...');
                // Fallback to local path (handles dev/legacy)
                const fallback = await fetch('/cache/trend-data.json');
                return fallback.ok ? fallback.json() : {};
            }
            return res.json();
        })
        .then(data => { _trendCache = data; return data; })
        .catch((err) => {
            console.error('[MiniTrend] Trend data load failed:', err);
            return {};
        });
    
    return _loadPromise;
}

function drawSparkline(
    canvas: HTMLCanvasElement, 
    scores: number[],
    direction: 'up' | 'down' | 'stable'
) {
    const ctx = canvas.getContext('2d');
    if (!ctx || scores.length < 2) return;
    
    const w = canvas.width, h = canvas.height;
    const pad = 3;
    const max = Math.max(...scores), min = Math.min(...scores);
    const range = max - min || 1;
    
    ctx.clearRect(0, 0, w, h);
    ctx.beginPath();
    ctx.strokeStyle = direction === 'up' ? '#22c55e' : 
                      direction === 'down' ? '#ef4444' : '#9ca3af';
    ctx.lineWidth = 1.5;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    scores.forEach((s, i) => {
        const x = pad + (i / (scores.length - 1)) * (w - pad * 2);
        const y = h - pad - ((s - min) / range) * (h - pad * 2);
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    });
    ctx.stroke();
    canvas.classList.add('loaded');
}

function updateBadge(el: HTMLElement, change: number, dir: string) {
    const arrow = dir === 'up' ? '↑' : dir === 'down' ? '↓' : '→';
    el.textContent = `${arrow}${Math.abs(change).toFixed(1)}%`;
    el.className = `mini-trend-badge ${dir}`;
}

async function initMiniTrends() {
    const charts = document.querySelectorAll('.mini-trend:not(.inited)');
    if (!charts.length) return;
    
    const data = await loadTrendData();
    const dataKeys = Object.keys(data);
    const dataKeysLower = dataKeys.map(k => k.toLowerCase());
    
    charts.forEach(el => {
        let id = (el as HTMLElement).dataset.entityId;
        if (!id) return;
        
        let targetId = id;
        
        // V16.34: Aggressive Identity Matching (Prefix-Stripping + Includes)
        const normalize = (s: string) => s.toLowerCase().replace(/[:\/]+/g, '--');
        const nid = normalize(id);
        const bareId = nid.replace(/^(hf-model|hf-dataset|hf-space|hf-tool|model|agent|dataset|paper|space|tool)--/, '');
        
        // 1. Try exact match
        if (!data[targetId]) {
            // 2. Try normalized match
            const idx = dataKeysLower.indexOf(nid);
            if (idx !== -1) {
                targetId = dataKeys[idx];
            } else {
                // 3. Try "includes" match (e.g. if JSON has prefix but page doesn't or vice versa)
                const includesIdx = dataKeysLower.findIndex(k => k.includes(bareId) || bareId.includes(k.replace(/^(hf-model|model)--/, '')));
                if (includesIdx !== -1) {
                    targetId = dataKeys[includesIdx];
                } else {
                    // 4. Try "bare" name matching (last part of slug)
                    const bareName = nid.split('--').pop();
                    if (bareName) {
                        const bareIdx = dataKeysLower.findIndex(k => k.endsWith(`--${bareName}`) || k === bareName);
                        if (bareIdx !== -1) targetId = dataKeys[bareIdx];
                    }
                }
            }
        }

        if (!data[targetId]) {
            console.warn('[MiniTrend] No data for:', id, '(nid:', nid, ')');
            return;
        }
        
        const d = data[targetId];
        const canvas = el.querySelector('canvas');
        const badge = el.querySelector('.mini-trend-badge') as HTMLElement;
        
        // Defensive: Check for scores array
        if (canvas) {
            const scores = d.scores || (d.latest ? [d.latest, d.latest] : []);
            if (scores.length >= 2) {
                drawSparkline(canvas as HTMLCanvasElement, scores, d.direction || 'stable');
                
                // V16.34: UniversalCore Signal - Hide "Synchronizing" mask
                const fallback = el.parentElement?.querySelector('#trend-fallback');
                if (fallback) fallback.classList.add('hidden-permanent');
            }
        }
        if (badge) {
            updateBadge(badge, d.change7d || 0, d.direction || 'stable');
        }
        el.classList.add('inited');
    });
}

// Init
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMiniTrends);
} else {
    initMiniTrends();
}
document.addEventListener('astro:page-load', initMiniTrends);
</script>
