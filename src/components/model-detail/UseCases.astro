---
/**
 * UseCases Component - Zone 1.5
 * V15.0: Display use cases derived from pipeline_tag
 * 
 * Shows what the model is good for and what it might not be suitable for
 * Based on static mapping (Constitutional: no AI inference)
 */

interface Props {
  pipelineTag?: string;
  tags?: string[];
  contextLength?: number;
  entityType?: string;
}

const { pipelineTag, tags = [], contextLength, entityType = 'model' } = Astro.props;

// V15.0: Static mapping from pipeline_tag to use cases (CES compliant - English)
const USE_CASE_MAP: Record<string, { good: string[], notGood: string[] }> = {
  'text-generation': {
    good: ['Chat', 'Text Continuation', 'Creative Writing', 'Code Generation'],
    notGood: ['Image Processing', 'Speech Recognition']
  },
  'text2text-generation': {
    good: ['Translation', 'Summarization', 'Q&A', 'Paraphrasing'],
    notGood: ['Long Document Generation', 'Creative Writing']
  },
  'text-to-image': {
    good: ['Image Generation', 'AI Art', 'Concept Design', 'Illustration'],
    notGood: ['Text Tasks', 'Code Generation']
  },
  'image-to-text': {
    good: ['Image Captioning', 'OCR', 'Chart Understanding'],
    notGood: ['Text Generation', 'Chat']
  },
  'feature-extraction': {
    good: ['Embeddings', 'RAG Retrieval', 'Semantic Search', 'Similarity'],
    notGood: ['Direct Chat', 'Content Generation']
  },
  'fill-mask': {
    good: ['Text Completion', 'Cloze Test'],
    notGood: ['Long Text Generation', 'Chat']
  },
  'question-answering': {
    good: ['Q&A Systems', 'Reading Comprehension', 'Knowledge QA'],
    notGood: ['Long Generation', 'Creative Writing']
  },
  'summarization': {
    good: ['Text Summary', 'Key Points', 'Meeting Notes'],
    notGood: ['Chat', 'Creative Writing']
  },
  'translation': {
    good: ['Multilingual Translation', 'Localization'],
    notGood: ['Creative Writing', 'Code Generation']
  },
  'automatic-speech-recognition': {
    good: ['Speech-to-Text', 'Meeting Transcription', 'Subtitles'],
    notGood: ['Text Generation', 'Translation']
  },
  'text-to-speech': {
    good: ['Voice Synthesis', 'Audiobooks', 'Dubbing'],
    notGood: ['Text Understanding', 'Chat']
  },
  'object-detection': {
    good: ['Object Detection', 'Image Analysis', 'Surveillance'],
    notGood: ['Text Tasks', 'Speech Tasks']
  },
  'image-classification': {
    good: ['Image Classification', 'Content Moderation', 'Tag Recognition'],
    notGood: ['Text Tasks', 'Generation Tasks']
  },
  'image-segmentation': {
    good: ['Image Segmentation', 'Background Removal', 'Object Extraction'],
    notGood: ['Text Tasks', 'Generation Tasks']
  },
  'zero-shot-classification': {
    good: ['Zero-shot Classification', 'Topic Classification', 'Sentiment Analysis'],
    notGood: ['Long Generation', 'Chat']
  },
  'sentence-similarity': {
    good: ['Semantic Similarity', 'Text Matching', 'Duplicate Detection'],
    notGood: ['Content Generation', 'Chat']
  },
  'other': {
    good: ['General AI Tasks'],
    notGood: []
  }
};

// Get use cases based on pipeline_tag
const tag = pipelineTag?.toLowerCase() || 'other';
const useCases = USE_CASE_MAP[tag] || USE_CASE_MAP['other'];

// Add context-based warnings
if (contextLength && contextLength < 32768) {
  if (!useCases.notGood.includes('Long Documents (context < 32K)')) {
    useCases.notGood = [...useCases.notGood, 'Long Documents (context < 32K)'];
  }
}

// Check for specific capabilities from tags
const hasCode = tags.some(t => t.includes('code') || t.includes('coding'));
const hasChat = tags.some(t => t.includes('chat') || t.includes('instruct'));
const hasVision = tags.some(t => t.includes('vision') || t.includes('multimodal'));

if (hasCode && !useCases.good.includes('Code Generation')) {
  useCases.good = [...useCases.good, 'Code Generation'];
}
if (hasChat && !useCases.good.includes('Chat')) {
  useCases.good = ['Chat', ...useCases.good];
}
if (hasVision && !useCases.good.includes('Multimodal')) {
  useCases.good = [...useCases.good, 'Multimodal'];
}

const hasUseCases = useCases.good.length > 0 || useCases.notGood.length > 0;
---

{hasUseCases && (
  <section class="use-cases-section bg-gradient-to-r from-emerald-50 to-teal-50 dark:from-emerald-900/20 dark:to-teal-900/20 rounded-xl p-4 mb-6 border border-emerald-200 dark:border-emerald-800">
    <div class="flex flex-wrap gap-4">
      {useCases.good.length > 0 && (
        <div class="flex items-start gap-2 flex-1 min-w-[200px]">
          <span class="text-emerald-600 dark:text-emerald-400 text-lg">✅</span>
          <div>
            <span class="text-sm font-medium text-emerald-700 dark:text-emerald-300">Good for:</span>
            <div class="flex flex-wrap gap-1 mt-1">
              {useCases.good.map(uc => (
                <span class="inline-block px-2 py-0.5 text-xs bg-emerald-100 dark:bg-emerald-800/50 text-emerald-700 dark:text-emerald-300 rounded-full">
                  {uc}
                </span>
              ))}
            </div>
          </div>
        </div>
      )}
      
      {useCases.notGood.length > 0 && (
        <div class="flex items-start gap-2 flex-1 min-w-[200px]">
          <span class="text-amber-600 dark:text-amber-400 text-lg">⚠️</span>
          <div>
            <span class="text-sm font-medium text-amber-700 dark:text-amber-300">May not suit:</span>
            <div class="flex flex-wrap gap-1 mt-1">
              {useCases.notGood.map(uc => (
                <span class="inline-block px-2 py-0.5 text-xs bg-amber-100 dark:bg-amber-800/50 text-amber-700 dark:text-amber-300 rounded-full">
                  {uc}
                </span>
              ))}
            </div>
          </div>
        </div>
      )}
    </div>
  </section>
)}
