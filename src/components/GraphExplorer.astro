---
// src/components/GraphExplorer.astro
const { modelId } = Astro.props;
// Build timestamp for cache-busting API requests
const buildTime = import.meta.env.PUBLIC_BUILD_TIME || Date.now().toString();
---

<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6 my-8" id="graph-explorer">
    <div class="flex justify-between items-center mb-4">
        <h3 class="text-xl font-bold text-gray-900 dark:text-white flex items-center gap-2">
            <span class="text-lg">üï∏Ô∏è</span> Neural Network Explorer
        </h3>
        <div class="flex gap-2 text-xs">
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-blue-500"></span> Model</span>
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-purple-500"></span> Paper</span>
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-green-500"></span> Benchmark</span>
        </div>
    </div>
    
    <!-- Content Activation: Explain what the Explorer is for -->
    <div class="bg-blue-50 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 text-sm p-3 rounded-lg mb-4">
        <p><strong>‚ÑπÔ∏è About this graph:</strong> This visualizes relationships between models, datasets, and papers. 
        It does <strong>NOT</strong> evaluate quality or performance. Use it to explore connections, not rankings.</p>
    </div>
    
    <div id="graph-container" data-model-id={modelId} data-build-time={buildTime} class="w-full h-[300px] bg-gray-50 dark:bg-gray-900 rounded-lg overflow-hidden relative cursor-grab border border-gray-100 dark:border-gray-800">
        <div id="graph-loading" class="absolute inset-0 flex items-center justify-center bg-white/80 dark:bg-gray-800/80 z-10 transition-opacity duration-300">
            <div class="flex flex-col items-center">
                <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-indigo-600"></div>
                <p class="mt-2 text-gray-500 text-sm">Mapping neural connections...</p>
            </div>
        </div>
        <svg id="d3-graph" class="w-full h-full"></svg>
    </div>
</div>

<!-- V4.6 Performance: Defer D3.js to not block LCP -->
<script defer src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script is:inline>
    // V4 Stable D1: requestIdleCallback + Intersection Observer for true idle loading
    // Only initialize when: 1) browser is idle AND 2) component is visible
    (function() {
        function initGraphExplorer() {
            const container = document.getElementById('graph-container');
            if (!container) {
                console.warn('[GraphExplorer] Container not found');
                return;
            }
            
            const modelId = container.dataset.modelId;
            const buildTime = container.dataset.buildTime || Date.now();
            if (!modelId) {
                console.error('[GraphExplorer] modelId not found in dataset');
                return;
            }
        
        const svg = d3.select("#d3-graph");
        const loading = document.getElementById('graph-loading');
        
        // Config
        let width = container.clientWidth;
        let height = container.clientHeight;
        
        // Force Simulation
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide(30));
        
        // Resize handler
        window.addEventListener('resize', function() {
            width = container.clientWidth;
            height = container.clientHeight;
            svg.attr("width", width).attr("height", height);
            simulation.force("center", d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        });
        
        // Fetch Data
        function loadGraphData() {
            console.log('[Graph] Loading for ' + modelId);
            // Include build time for cache-busting to prevent stale data
            fetch('/api/graph/neighbors.json?id=' + encodeURIComponent(modelId) + '&v=' + buildTime)
                .then(function(response) {
                    if (!response.ok) {
                        return response.text().then(function(errText) {
                            throw new Error('API Error ' + response.status + ': ' + errText.substring(0, 100));
                        });
                    }
                    return response.json();
                })
                .then(function(data) {
                    if (!data.nodes || data.nodes.length === 0) {
                        loading.innerHTML = '<p class="text-gray-500">No relationships mapped yet.</p>';
                        loading.style.display = 'flex';
                        return;
                    }
                    renderGraph(data);
                    loading.style.opacity = '0';
                    setTimeout(function() { loading.style.display = 'none'; }, 300);
                })
                .catch(function(error) {
                    console.error("[Graph Error]", error);
                    loading.innerHTML = '<div class="text-center p-4"><p class="text-red-500 font-bold">Failed to load graph</p><p class="text-xs text-red-400 mt-1">' + error.message + '</p></div>';
                    loading.style.display = 'flex';
                });
        }
        
        function renderGraph(data) {
            svg.selectAll("*").remove();
            
            var g = svg.append("g");
            
            // Zoom capability (drag only, no wheel to avoid scroll interference)
            var zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .filter(function(event) {
                    // Disable wheel zoom to not interfere with page scroll
                    return event.type !== 'wheel';
                })
                .on("zoom", function(event) {
                    g.attr("transform", event.transform);
                });
            svg.call(zoom);
            
            // Links
            var link = g.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(data.links)
                .join("line")
                .attr("stroke-width", function(d) { return Math.sqrt(d.value || 1); });
            
            // Nodes
            var node = g.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(data.nodes)
                .join("circle")
                .attr("r", function(d) { return d.id === modelId ? 12 : 8; })
                .attr("fill", function(d) { return getNodeColor(d.group); })
                .style("cursor", function(d) { return d.group === 'model' ? 'pointer' : 'default'; })
                .call(drag(simulation));
            
            // Labels
            var labels = g.append("g")
                .attr("class", "labels")
                .selectAll("text")
                .data(data.nodes)
                .join("text")
                .attr("dx", 12)
                .attr("dy", ".35em")
                .text(function(d) { return d.name; })
                .attr("fill", "currentColor")
                .attr("class", "text-xs font-medium dark:fill-white fill-gray-900 pointer-events-none");
            
            // Tooltip
            node.append("title")
                .text(function(d) { return d.name + ' (' + d.group + ')'; });
            
            // Click Event - Navigate to related models
            node.on("click", function(event, d) {
                if (d.group === 'model' && d.slug) {
                    window.location.href = '/model/' + d.slug;
                } else if (d.group === 'main') {
                    // Already on this page, do nothing
                } else if (d.url) {
                    window.open(d.url, '_blank');
                }
            });
            
            // Simulation Tick
            simulation
                .nodes(data.nodes)
                .on("tick", function() {
                    link
                        .attr("x1", function(d) { return d.source.x; })
                        .attr("y1", function(d) { return d.source.y; })
                        .attr("x2", function(d) { return d.target.x; })
                        .attr("y2", function(d) { return d.target.y; });
                    
                    node
                        .attr("cx", function(d) { return d.x; })
                        .attr("cy", function(d) { return d.y; });
                    
                    labels
                        .attr("x", function(d) { return d.x; })
                        .attr("y", function(d) { return d.y; });
                });
            
            simulation.force("link").links(data.links);
        }
        
        function getNodeColor(group) {
            switch(group) {
                case 'main': return '#EF4444';
                case 'model': return '#3B82F6';
                case 'paper': return '#8B5CF6';
                case 'benchmark': return '#10B981';
                default: return '#6B7280';
            }
        }
        
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }
            
            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }
            
            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }
            
            return d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended);
        }
        
        // Load
        loadGraphData();
        }
        
        // V4 Stable D1: Only initialize when visible AND browser is idle
        const scheduleInit = function() {
            const explorer = document.getElementById('graph-explorer');
            if (!explorer) return;
            
            // Use Intersection Observer for visibility detection
            const observer = new IntersectionObserver(function(entries) {
                if (entries[0].isIntersecting) {
                    observer.disconnect();
                    // Use requestIdleCallback for true idle loading
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(initGraphExplorer, { timeout: 3000 });
                    } else {
                        setTimeout(initGraphExplorer, 200);
                    }
                }
            }, { rootMargin: '100px' });
            
            observer.observe(explorer);
        };
        
        // Wait for D3 to load before scheduling
        if (typeof d3 !== 'undefined') {
            scheduleInit();
        } else {
            window.addEventListener('load', scheduleInit);
        }
    })();
</script>

