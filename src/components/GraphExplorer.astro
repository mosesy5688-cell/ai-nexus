---
// src/components/GraphExplorer.astro
const { modelId } = Astro.props;
// Build timestamp for cache-busting requests
import { R2_CACHE_URL } from '../config/constants.ts';
const buildTime = import.meta.env.PUBLIC_BUILD_TIME || Date.now().toString();
---

<div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg border border-gray-200 dark:border-gray-700 p-6 my-8" id="graph-explorer">
    <div class="flex justify-between items-center mb-4">
        <h3 class="text-xl font-bold text-gray-900 dark:text-white flex items-center gap-2">
            <span class="text-lg">üï∏Ô∏è</span> Neural Network Explorer
        </h3>
        <div class="flex gap-2 text-xs">
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-blue-500"></span> Model</span>
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-purple-500"></span> Paper</span>
            <span class="flex items-center gap-1"><span class="w-3 h-3 rounded-full bg-green-500"></span> Benchmark</span>
        </div>
    </div>
    
    <!-- Content Activation: Explain what the Explorer is for -->
    <div class="bg-blue-50 dark:bg-blue-900/30 text-blue-800 dark:text-blue-200 text-sm p-3 rounded-lg mb-4">
        <p><strong>‚ÑπÔ∏è About this graph:</strong> This visualizes relationships between models, datasets, and papers. 
        It does <strong>NOT</strong> evaluate quality or performance. Use it to explore connections, not rankings.</p>
    </div>
    
    <div id="graph-container" data-model-id={modelId} data-build-time={buildTime} class="w-full h-[300px] bg-gray-50 dark:bg-gray-900 rounded-lg overflow-hidden relative cursor-grab border border-gray-100 dark:border-gray-800">
        <div id="graph-loading" class="absolute inset-0 flex items-center justify-center bg-white/80 dark:bg-gray-800/80 z-10 transition-opacity duration-300">
            <div class="flex flex-col items-center">
                <div class="animate-spin rounded-full h-10 w-10 border-b-2 border-indigo-600"></div>
                <p class="mt-2 text-gray-500 text-sm">Mapping neural connections...</p>
            </div>
        </div>
        <svg id="d3-graph" class="w-full h-full"></svg>
    </div>
</div>

<script>
    import { getRouteFromId, getTypeFromId } from '../utils/mesh-routing-core.js';
    import { R2_CACHE_URL } from '../config/constants.ts';

    function initGraphExplorer() {
        const container = document.getElementById('graph-container');
        if (!container) return;
        
        const modelId = container.dataset.modelId;
        const buildTime = container.dataset.buildTime || Date.now();
        if (!modelId) return;
    
        const svg = d3.select("#d3-graph");
        const loading = document.getElementById('graph-loading');
        
        let width = container.clientWidth;
        let height = container.clientHeight;
        
        const simulation = d3.forceSimulation()
            .force("link", d3.forceLink().id(d => d.id).distance(100))
            .force("charge", d3.forceManyBody().strength(-300))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collide", d3.forceCollide(30));
        
        window.addEventListener('resize', () => {
            width = container.clientWidth;
            height = container.clientHeight;
            svg.attr("width", width).attr("height", height);
            simulation.force("center", d3.forceCenter(width / 2, height / 2));
            simulation.alpha(0.3).restart();
        });
        
        function loadGraphData() {
            const cdnUrl = `${R2_CACHE_URL}/cache/graph/neighbors/${encodeURIComponent(modelId)}.json?v=${buildTime}`;
            fetch(cdnUrl)
                .then(r => {
                    if (!r.ok) throw new Error(`HTTP ${r.status}`);
                    return r.json();
                })
                .then(data => {
                    if (!data.nodes || data.nodes.length === 0) {
                        loading.innerHTML = '<p class="text-gray-500">No relationships mapped yet.</p>';
                        return;
                    }
                    renderGraph(data);
                    loading.style.opacity = '0';
                    setTimeout(() => { loading.style.display = 'none'; }, 300);
                })
                .catch(err => {
                    console.error("[Graph Error]", err);
                    loading.innerHTML = `<div class="text-center p-4"><p class="text-red-500 font-bold">Failed to load graph</p></div>`;
                });
        }
        
        function renderGraph(data) {
            svg.selectAll("*").remove();
            const g = svg.append("g");
            
            const zoom = d3.zoom()
                .scaleExtent([0.5, 2])
                .filter(event => event.type !== 'wheel')
                .on("zoom", event => { g.attr("transform", event.transform); });
            svg.call(zoom);
            
            const link = g.append("g")
                .attr("stroke", "#999")
                .attr("stroke-opacity", 0.6)
                .selectAll("line")
                .data(data.links)
                .join("line")
                .attr("stroke-width", d => Math.sqrt(d.value || 1));
            
            const node = g.append("g")
                .attr("stroke", "#fff")
                .attr("stroke-width", 1.5)
                .selectAll("circle")
                .data(data.nodes)
                .join("circle")
                .attr("r", d => d.id === modelId ? 12 : 8)
                .attr("fill", d => getNodeColor(d.group))
                .style("cursor", d => (d.group === 'model' || d.group === 'paper' || d.group === 'benchmark') ? 'pointer' : 'default')
                .call(drag(simulation));
            
            const labels = g.append("g")
                .attr("class", "labels")
                .selectAll("text")
                .data(data.nodes)
                .join("text")
                .attr("dx", 12)
                .attr("dy", ".35em")
                .text(d => d.name)
                .attr("fill", "currentColor")
                .attr("class", "text-xs font-medium dark:fill-white fill-gray-900 pointer-events-none");
            
            node.append("title").text(d => `${d.name} (${d.group})`);
            
            node.on("click", (event, d) => {
                // V18.12.5.16: Use Canonical Routing Utility
                const path = getRouteFromId(d.id, d.group);
                if (path && path !== '#') {
                    window.location.href = path;
                } else if (d.url) {
                    window.open(d.url, '_blank');
                }
            });
            
            simulation.nodes(data.nodes).on("tick", () => {
                link.attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                node.attr("cx", d => d.x).attr("cy", d => d.y);
                labels.attr("x", d => d.x).attr("y", d => d.y);
            });
            simulation.force("link").links(data.links);
        }
        
        function getNodeColor(group) {
            switch(group) {
                case 'main': return '#EF4444';
                case 'model': return '#3B82F6';
                case 'paper': return '#8B5CF6';
                case 'benchmark': return '#10B981';
                default: return '#6B7280';
            }
        }
        
        function drag(simulation) {
            return d3.drag()
                .on("start", (event) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    event.subject.fx = event.subject.x;
                    event.subject.fy = event.subject.y;
                })
                .on("drag", (event) => {
                    event.subject.fx = event.x;
                    event.subject.fy = event.y;
                })
                .on("end", (event) => {
                    if (!event.active) simulation.alphaTarget(0);
                    event.subject.fx = null;
                    event.subject.fy = null;
                });
        }
        
        loadGraphData();
    }
    
    const scheduleInit = () => {
        const explorer = document.getElementById('graph-explorer');
        if (!explorer) return;
        
        const observer = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting) {
                observer.disconnect();
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(initGraphExplorer, { timeout: 3000 });
                } else {
                    setTimeout(initGraphExplorer, 200);
                }
            }
        }, { rootMargin: '100px' });
        
        observer.observe(explorer);
    };
    
    if (typeof d3 !== 'undefined') {
        scheduleInit();
    } else {
        window.addEventListener('load', scheduleInit);
    }
</script>

